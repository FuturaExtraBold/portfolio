{"version":3,"file":"static/js/499.c7c8a1f3.chunk.js","mappings":"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","sources":["../node_modules/pixi.js/src/rendering/high-shader/shader-bits/localUniformBit.ts","../node_modules/pixi.js/src/scene/sprite-tiling/shader/tilingBit.ts","../node_modules/pixi.js/src/scene/sprite-tiling/shader/TilingSpriteShader.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/QuadGeometry.ts","../node_modules/pixi.js/src/scene/sprite-tiling/TilingSpritePipe.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/setUvs.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/applyMatrix.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/setPositions.ts","../node_modules/pixi.js/src/scene/sprite-tiling/init.ts","../node_modules/pixi.js/src/scene/mesh/shared/BatchableMesh.ts","../node_modules/pixi.js/src/app/ResizePlugin.ts","../node_modules/pixi.js/src/app/TickerPlugin.ts","../node_modules/pixi.js/src/app/init.ts","../node_modules/pixi.js/src/scene/sprite/BatchableSprite.ts","../node_modules/pixi.js/src/scene/graphics/shared/GraphicsPipe.ts","../node_modules/pixi.js/src/scene/graphics/init.ts","../node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/localUniformMSDFBit.ts","../node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/mSDFBit.ts","../node_modules/pixi.js/src/scene/text/sdfShader/SdfShader.ts","../node_modules/pixi.js/src/scene/text-bitmap/BitmapTextPipe.ts","../node_modules/pixi.js/src/scene/text-bitmap/init.ts","../node_modules/pixi.js/src/scene/text/canvas/CanvasTextPipe.ts","../node_modules/pixi.js/src/utils/canvas/getCanvasBoundingBox.ts","../node_modules/pixi.js/src/scene/text/canvas/CanvasTextSystem.ts","../node_modules/pixi.js/src/scene/text/init.ts","../node_modules/pixi.js/src/scene/mesh/shared/MeshPipe.ts","../node_modules/pixi.js/src/scene/mesh/init.ts","../node_modules/pixi.js/src/scene/text/utils/getPo2TextureFromSource.ts","../node_modules/pixi.js/src/scene/mesh-plane/PlaneGeometry.ts","../node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceGeometry.ts","../node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceSpritePipe.ts","../node_modules/pixi.js/src/scene/sprite-nine-slice/init.ts","../node_modules/pixi.js/src/filters/FilterPipe.ts","../node_modules/pixi.js/src/filters/FilterSystem.ts","../node_modules/pixi.js/src/scene/container/bounds/getRenderableBounds.ts","../node_modules/pixi.js/src/filters/init.ts","../node_modules/pixi.js/src/scene/particle-container/gl/GlParticleContainerAdaptor.ts","../node_modules/pixi.js/src/scene/particle-container/shared/utils/createIndicesForQuads.ts","../node_modules/pixi.js/src/scene/particle-container/shared/utils/generateParticleUpdateFunction.ts","../node_modules/pixi.js/src/scene/particle-container/shared/ParticleBuffer.ts","../node_modules/pixi.js/src/scene/particle-container/shared/shader/ParticleShader.ts","../node_modules/pixi.js/src/scene/particle-container/shared/ParticleContainerPipe.ts","../node_modules/pixi.js/src/scene/particle-container/shared/GlParticleContainerPipe.ts","../node_modules/pixi.js/src/scene/particle-container/gpu/GpuParticleContainerAdaptor.ts","../node_modules/pixi.js/src/scene/particle-container/shared/GpuParticleContainerPipe.ts","../node_modules/pixi.js/src/scene/particle-container/init.ts","../node_modules/pixi.js/src/scene/text/utils/updateTextBounds.ts","../node_modules/pixi.js/src/scene/text-html/HTMLTextPipe.ts","../node_modules/pixi.js/src/scene/text-html/HTMLTextRenderData.ts","../node_modules/pixi.js/src/scene/text-html/utils/textStyleToCSS.ts","../node_modules/pixi.js/src/scene/text-html/HTMLTextStyle.ts","../node_modules/pixi.js/src/scene/text-html/utils/loadFontCSS.ts","../node_modules/pixi.js/src/scene/text-html/utils/loadFontAsBase64.ts","../node_modules/pixi.js/src/scene/text-html/utils/getFontCss.ts","../node_modules/pixi.js/src/scene/text-html/utils/measureHtmlText.ts","../node_modules/pixi.js/src/scene/text-html/HTMLTextSystem.ts","../node_modules/pixi.js/src/scene/text-html/utils/extractFontFamilies.ts","../node_modules/pixi.js/src/scene/text-html/utils/getSVGUrl.ts","../node_modules/pixi.js/src/scene/text-html/utils/loadSVGImage.ts","../node_modules/pixi.js/src/utils/browser/isSafari.ts","../node_modules/pixi.js/src/scene/text-html/utils/getTemporaryCanvasFromImage.ts","../node_modules/pixi.js/src/scene/text-html/init.ts","../node_modules/pixi.js/src/scene/graphics/gpu/colorToUniform.ts","../node_modules/pixi.js/src/scene/mesh/shared/MeshGeometry.ts"],"sourcesContent":["export const localUniformBit = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* wgsl */`\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n};\n\n// TODO this works, but i think down the road it will be better to manage groups automatically if there are clashes\nexport const localUniformBitGroup2 = {\n    ...localUniformBit,\n    vertex: {\n        ...localUniformBit.vertex,\n        // replace the group!\n        header: localUniformBit.vertex.header.replace('group(1)', 'group(2)'),\n    }\n};\n\nexport const localUniformBitGl = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* glsl */`\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n};\n","export const tilingBit = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            } \n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    }\n\n};\n\nexport const tilingBitGl = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n        \n        `,\n        main: /* glsl */`\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `,\n        main: /* glsl */`\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n        \n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n    \n        `\n    }\n\n};\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBit, localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { tilingBit, tilingBitGl } from './tilingBit';\n\nimport type { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport type { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\n\nlet gpuProgram: GpuProgram;\nlet glProgram: GlProgram;\n\nexport class TilingSpriteShader extends Shader\n{\n    constructor()\n    {\n        gpuProgram ??= compileHighShaderGpuProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBit,\n                tilingBit,\n                roundPixelsBit,\n            ],\n        });\n\n        glProgram ??= compileHighShaderGlProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBitGl,\n                tilingBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        const tilingUniforms = new UniformGroup({\n            uMapCoord: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: 'vec4<f32>' },\n            uClampOffset: { value: new Float32Array([0, 0]), type: 'vec2<f32>' },\n            uTextureTransform: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: 'vec4<f32>' },\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: new UniformGroup({\n                    uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n                    uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n                    uRound: { value: 0, type: 'f32' },\n                }),\n                tilingUniforms,\n                uTexture: Texture.EMPTY.source,\n                uSampler: Texture.EMPTY.source.style,\n            }\n        });\n    }\n\n    public updateUniforms(\n        width: number, height: number,\n        matrix: Matrix,\n        anchorX: number, anchorY: number,\n        texture: Texture\n    ): void\n    {\n        const tilingUniforms = this.resources.tilingUniforms;\n\n        const textureWidth = texture.width;\n        const textureHeight = texture.height;\n        const textureMatrix = texture.textureMatrix;\n\n        const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n\n        uTextureTransform.set(\n            matrix.a * textureWidth / width,\n            matrix.b * textureWidth / height,\n            matrix.c * textureHeight / width,\n            matrix.d * textureHeight / height,\n            matrix.tx / width,\n            matrix.ty / height);\n\n        uTextureTransform.invert();\n\n        tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n        tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n        tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n        tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n        tilingUniforms.uniforms.uSizeAnchor[0] = width;\n        tilingUniforms.uniforms.uSizeAnchor[1] = height;\n        tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n        tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n\n        if (texture)\n        {\n            this.resources.uTexture = texture.source;\n            this.resources.uSampler = texture.source.style;\n        }\n    }\n}\n","import { MeshGeometry } from '../../mesh/shared/MeshGeometry';\n\nexport class QuadGeometry extends MeshGeometry\n{\n    constructor()\n    {\n        super({\n            positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            indices: new Uint32Array([0, 1, 2, 0, 2, 3]),\n        });\n    }\n}\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { getAdjustedBlendModeBlend } from '../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { State } from '../../rendering/renderers/shared/state/State';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { color32BitToUniform } from '../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\nimport { TilingSpriteShader } from './shader/TilingSpriteShader';\nimport { QuadGeometry } from './utils/QuadGeometry';\nimport { setPositions } from './utils/setPositions';\nimport { setUvs } from './utils/setUvs';\n\nimport type { WebGLRenderer } from '../../rendering/renderers/gl/WebGLRenderer';\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Container } from '../container/Container';\nimport type { TilingSprite } from './TilingSprite';\n\ninterface RenderableData\n{\n    canBatch: boolean;\n    renderable: TilingSprite\n    batchableMesh?: BatchableMesh;\n    geometry?: MeshGeometry;\n    shader?: TilingSpriteShader;\n}\n\nconst sharedQuad = new QuadGeometry();\n\nexport class TilingSpritePipe implements RenderPipe<TilingSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'tilingSprite',\n    } as const;\n\n    private _renderer: Renderer;\n    private readonly _state: State = State.default2d;\n    private readonly _tilingSpriteDataHash: Record<number, RenderableData> = Object.create(null);\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_tilingSpriteDataHash');\n    }\n\n    public validateRenderable(renderable: TilingSprite): boolean\n    {\n        const tilingSpriteData = this._getTilingSpriteData(renderable);\n\n        const couldBatch = tilingSpriteData.canBatch;\n\n        this._updateCanBatch(renderable);\n\n        const canBatch = tilingSpriteData.canBatch;\n\n        if (canBatch && canBatch === couldBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            return !batchableMesh._batcher.checkAndUpdateTexture(\n                batchableMesh,\n                renderable.texture\n            );\n        }\n\n        return (couldBatch !== canBatch);\n\n        // // TODO - only update if required?\n        // // only texture\n        // // only uvs\n        // // only positions?\n    }\n\n    public addRenderable(tilingSprite: TilingSprite, instructionSet: InstructionSet)\n    {\n        const batcher = this._renderer.renderPipes.batch;\n\n        // init\n        this._updateCanBatch(tilingSprite);\n\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry, canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            tilingSpriteData.batchableMesh ||= new BatchableMesh();\n\n            const batchableMesh = tilingSpriteData.batchableMesh;\n\n            if (tilingSprite.didViewUpdate)\n            {\n                this._updateBatchableMesh(tilingSprite);\n\n                batchableMesh.geometry = geometry;\n                batchableMesh.renderable = tilingSprite;\n                batchableMesh.transform = tilingSprite.groupTransform;\n                batchableMesh.setTexture(tilingSprite._texture);\n            }\n\n            batchableMesh.roundPixels = (this._renderer._roundPixels | tilingSprite._roundPixels) as 0 | 1;\n\n            batcher.addToBatch(batchableMesh, instructionSet);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            tilingSpriteData.shader ||= new TilingSpriteShader();\n\n            this.updateRenderable(tilingSprite);\n\n            instructionSet.add(tilingSprite);\n        }\n    }\n\n    public execute(tilingSprite: TilingSprite)\n    {\n        const { shader } = this._tilingSpriteDataHash[tilingSprite.uid];\n\n        shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n\n        // deal with local uniforms...\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n        localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n\n        color32BitToUniform(\n            tilingSprite.groupColorAlpha,\n            localUniforms.uColor,\n            0\n        );\n\n        this._state.blendMode = getAdjustedBlendModeBlend(tilingSprite.groupBlendMode, tilingSprite.texture._source);\n\n        this._renderer.encoder.draw({\n            geometry: sharedQuad,\n            shader,\n            state: this._state,\n        });\n    }\n\n    public updateRenderable(tilingSprite: TilingSprite)\n    {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            if (tilingSprite.didViewUpdate) this._updateBatchableMesh(tilingSprite);\n\n            batchableMesh._batcher.updateElement(batchableMesh);\n        }\n        else if (tilingSprite.didViewUpdate)\n        {\n            const { shader } = tilingSpriteData;\n            // now update uniforms...\n\n            shader.updateUniforms(\n                tilingSprite.width,\n                tilingSprite.height,\n                tilingSprite._tileTransform.matrix,\n                tilingSprite.anchor.x,\n                tilingSprite.anchor.y,\n                tilingSprite.texture,\n            );\n        }\n    }\n\n    public destroyRenderable(tilingSprite: TilingSprite)\n    {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        tilingSpriteData.batchableMesh = null;\n\n        tilingSpriteData.shader?.destroy();\n\n        this._tilingSpriteDataHash[tilingSprite.uid] = null;\n\n        tilingSprite.off('destroyed', this._destroyRenderableBound);\n    }\n\n    private _getTilingSpriteData(renderable: TilingSprite): RenderableData\n    {\n        return this._tilingSpriteDataHash[renderable.uid] || this._initTilingSpriteData(renderable);\n    }\n\n    private _initTilingSpriteData(tilingSprite: TilingSprite): RenderableData\n    {\n        const geometry = new MeshGeometry({\n            indices: sharedQuad.indices,\n            positions: sharedQuad.positions.slice(),\n            uvs: sharedQuad.uvs.slice(),\n        });\n\n        this._tilingSpriteDataHash[tilingSprite.uid] = {\n            canBatch: true,\n            renderable: tilingSprite,\n            geometry,\n        };\n\n        tilingSprite.on('destroyed', this._destroyRenderableBound);\n\n        return this._tilingSpriteDataHash[tilingSprite.uid];\n    }\n\n    private _updateBatchableMesh(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry } = renderableData;\n\n        const style = tilingSprite.texture.source.style;\n\n        if (style.addressMode !== 'repeat')\n        {\n            style.addressMode = 'repeat';\n            style.update();\n        }\n\n        setUvs(tilingSprite, geometry.uvs);\n        setPositions(tilingSprite, geometry.positions);\n    }\n\n    public destroy()\n    {\n        for (const i in this._tilingSpriteDataHash)\n        {\n            this.destroyRenderable(this._tilingSpriteDataHash[i].renderable);\n        }\n\n        (this._tilingSpriteDataHash as null) = null;\n        this._renderer = null;\n    }\n\n    private _updateCanBatch(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n        const texture = tilingSprite.texture;\n\n        let _nonPowOf2wrapping = true;\n\n        if (this._renderer.type === RendererType.WEBGL)\n        {\n            _nonPowOf2wrapping = (this._renderer as WebGLRenderer).context.supports.nonPowOf2wrapping;\n        }\n\n        renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n\n        return renderableData.canBatch;\n    }\n}\n\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { applyMatrix } from './applyMatrix';\n\nimport type { TilingSprite } from '../TilingSprite';\n\nexport function setUvs(tilingSprite: TilingSprite, uvs: Float32Array)\n{\n    const texture = tilingSprite.texture;\n\n    const width = texture.frame.width;\n    const height = texture.frame.height;\n\n    let anchorX = 0;\n    let anchorY = 0;\n\n    if (tilingSprite.applyAnchorToTexture)\n    {\n        anchorX = tilingSprite.anchor.x;\n        anchorY = tilingSprite.anchor.y;\n    }\n\n    uvs[0] = uvs[6] = -anchorX;\n    uvs[2] = uvs[4] = 1 - anchorX;\n    uvs[1] = uvs[3] = -anchorY;\n    uvs[5] = uvs[7] = 1 - anchorY;\n\n    const textureMatrix = Matrix.shared;\n\n    textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n\n    textureMatrix.tx /= tilingSprite.width;\n    textureMatrix.ty /= tilingSprite.height;\n\n    textureMatrix.invert();\n\n    textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n\n    applyMatrix(uvs, 2, 0, textureMatrix);\n}\n","import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { TypedArray } from '../../../rendering/renderers/shared/buffer/Buffer';\n\nexport function applyMatrix(array: TypedArray, stride: number, offset: number, matrix: Matrix)\n{\n    let index = 0;\n    const size = array.length / (stride || 2);\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    offset *= stride;\n\n    while (index < size)\n    {\n        const x = array[offset];\n        const y = array[offset + 1];\n\n        array[offset] = (a * x) + (c * y) + tx;\n        array[offset + 1] = (b * x) + (d * y) + ty;\n\n        offset += stride;\n\n        index++;\n    }\n}\n","import type { TilingSprite } from '../TilingSprite';\n\nexport function setPositions(tilingSprite: TilingSprite, positions: Float32Array)\n{\n    const anchorX = tilingSprite.anchor.x;\n    const anchorY = tilingSprite.anchor.y;\n\n    positions[0] = -anchorX * tilingSprite.width;\n    positions[1] = -anchorY * tilingSprite.height;\n    positions[2] = (1 - anchorX) * tilingSprite.width;\n    positions[3] = -anchorY * tilingSprite.height;\n    positions[4] = (1 - anchorX) * tilingSprite.width;\n    positions[5] = (1 - anchorY) * tilingSprite.height;\n    positions[6] = -anchorX * tilingSprite.width;\n    positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { TilingSpritePipe } from './TilingSpritePipe';\n\nextensions.add(TilingSpritePipe);\n","import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableMeshElement } from '../../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { ViewContainer } from '../../view/ViewContainer';\nimport type { MeshGeometry } from './MeshGeometry';\n\n/**\n * A batchable mesh object.\n * @ignore\n */\nexport class BatchableMesh implements DefaultBatchableMeshElement\n{\n    public batcherName = 'default';\n\n    public _topology: Topology;\n\n    public readonly packAsQuad = false;\n    public location: number;\n\n    public renderable: ViewContainer;\n\n    public indexOffset = 0;\n    public attributeOffset = 0;\n\n    public texture: Texture;\n    public geometry: MeshGeometry;\n    public transform: Matrix;\n    public roundPixels: 0 | 1 = 0;\n\n    public _attributeStart: number;\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n    public _indexStart: number;\n    public _textureId: number;\n    public _textureMatrixUpdateId: number = -1;\n\n    private _transformedUvs: Float32Array;\n    private _uvUpdateId: number = -1;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n\n    get topology() { return this._topology || this.geometry.topology; }\n    set topology(value: Topology) { this._topology = value; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.geometry = null;\n        this._uvUpdateId = -1;\n        this._textureMatrixUpdateId = -1;\n    }\n\n    /**\n     * Sets the texture for the batchable mesh.\n     * As it does so, it resets the texture matrix update ID.\n     * this is to ensure that the texture matrix is recalculated when the uvs are referenced\n     * @param value - The texture to set.\n     */\n    public setTexture(value: Texture)\n    {\n        if (this.texture === value) return;\n\n        this.texture = value;\n        this._textureMatrixUpdateId = -1;\n    }\n\n    get uvs()\n    {\n        const geometry = this.geometry;\n\n        const uvBuffer = geometry.getBuffer('aUV');\n\n        const uvs = uvBuffer.data;\n\n        let transformedUvs = uvs;\n        const textureMatrix = this.texture.textureMatrix;\n\n        if (!textureMatrix.isSimple)\n        {\n            transformedUvs = this._transformedUvs;\n\n            if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID)\n            {\n                if (!transformedUvs || transformedUvs.length < uvs.length)\n                {\n                    transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n                }\n\n                this._textureMatrixUpdateId = textureMatrix._updateID;\n                this._uvUpdateId = uvBuffer._updateID;\n\n                textureMatrix.multiplyUvs(uvs as Float32Array, transformedUvs);\n            }\n        }\n\n        return transformedUvs as Float32Array;\n    }\n\n    get positions()\n    {\n        return this.geometry.positions;\n    }\n\n    get indices()\n    {\n        return this.geometry.indices;\n    }\n\n    get color()\n    {\n        return this.renderable.groupColorAlpha;\n    }\n\n    get groupTransform()\n    {\n        return this.renderable.groupTransform;\n    }\n\n    get attributeSize()\n    {\n        return this.geometry.positions.length / 2;\n    }\n\n    get indexSize()\n    {\n        return this.geometry.indices.length;\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\nimport type { Renderer } from '../rendering/renderers/types';\n\ntype ResizeableRenderer = Pick<Renderer, 'resize'>;\n\n/**\n * Application options for the {@link app.ResizePlugin}.\n * @memberof app\n * @property {Window|HTMLElement} [resizeTo=window] - Element to automatically resize the renderer to.\n */\nexport interface ResizePluginOptions\n{\n    /**\n     * Element to automatically resize the renderer to.\n     * @memberof app.ApplicationOptions\n     */\n    resizeTo?: Window | HTMLElement;\n}\n\n/**\n * Middleware for Application's resize functionality.\n *\n * Adds the following methods to {@link app.Application}:\n * * {@link app.Application#resizeTo}\n * * {@link app.Application#resize}\n * * {@link app.Application#queueResize}\n * * {@link app.Application#cancelResize}\n * @example\n * import { extensions, ResizePlugin } from 'pixi.js';\n *\n * extensions.add(ResizePlugin);\n * @memberof app\n */\nexport class ResizePlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n\n    public static resizeTo: Window | HTMLElement;\n    public static resize: () => void;\n    public static renderer: ResizeableRenderer;\n    public static queueResize: () => void;\n    public static render: () => void;\n    private static _resizeId: number;\n    private static _resizeTo: Window | HTMLElement;\n    private static _cancelResize: () => void;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @static\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options: ResizePluginOptions): void\n    {\n        Object.defineProperty(this, 'resizeTo',\n            /**\n             * The HTML element or window to automatically resize the\n             * renderer's view element to match width and height.\n             * @member {Window|HTMLElement}\n             * @name resizeTo\n             * @memberof app.Application#\n             */\n            {\n                set(dom: Window | HTMLElement)\n                {\n                    globalThis.removeEventListener('resize', this.queueResize);\n                    this._resizeTo = dom;\n                    if (dom)\n                    {\n                        globalThis.addEventListener('resize', this.queueResize);\n                        this.resize();\n                    }\n                },\n                get()\n                {\n                    return this._resizeTo;\n                },\n            });\n\n        /**\n         * Resize is throttled, so it's safe to call this multiple times per frame and it'll\n         * only be called once.\n         * @memberof app.Application#\n         * @method queueResize\n         * @private\n         */\n        this.queueResize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            this._cancelResize();\n\n            // // Throttle resize events per raf\n            this._resizeId = requestAnimationFrame(() => this.resize());\n        };\n\n        /**\n         * Cancel the resize queue.\n         * @memberof app.Application#\n         * @method cancelResize\n         * @private\n         */\n        this._cancelResize = (): void =>\n        {\n            if (this._resizeId)\n            {\n                cancelAnimationFrame(this._resizeId);\n                this._resizeId = null;\n            }\n        };\n\n        /**\n         * Execute an immediate resize on the renderer, this is not\n         * throttled and can be expensive to call many times in a row.\n         * Will resize only if `resizeTo` property is set.\n         * @memberof app.Application#\n         * @method resize\n         */\n        this.resize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            // clear queue resize\n            this._cancelResize();\n\n            let width: number;\n            let height: number;\n\n            // Resize to the window\n            if (this._resizeTo === globalThis.window)\n            {\n                width = globalThis.innerWidth;\n                height = globalThis.innerHeight;\n            }\n            // Resize to other HTML entities\n            else\n            {\n                const { clientWidth, clientHeight } = this._resizeTo as HTMLElement;\n\n                width = clientWidth;\n                height = clientHeight;\n            }\n\n            this.renderer.resize(width, height);\n            this.render();\n        };\n\n        // On resize\n        this._resizeId = null;\n        this._resizeTo = null;\n        this.resizeTo = options.resizeTo || null;\n    }\n\n    /**\n     * Clean up the ticker, scoped to application\n     * @static\n     * @private\n     */\n    public static destroy(): void\n    {\n        globalThis.removeEventListener('resize', this.queueResize);\n        this._cancelResize();\n        this._cancelResize = null;\n        this.queueResize = null;\n        this.resizeTo = null;\n        this.resize = null;\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { UPDATE_PRIORITY } from '../ticker/const';\nimport { Ticker } from '../ticker/Ticker';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Application options for the {@link app.TickerPlugin}.\n * @memberof app\n * @property {boolean} [autoStart=true] - Automatically starts the rendering after the construction.\n * **Note**: Setting this parameter to `false` does NOT stop the shared ticker even if you set\n * `options.sharedTicker` to `true` in case that it is already started. Stop it by your own.\n * @property {boolean} [sharedTicker=false] - Set`true` to use `Ticker.shared`, `false` to create new ticker.\n * If set to `false`, you cannot register a handler to occur before anything that runs on the shared ticker.\n * The system ticker will always run before both the shared ticker and the app ticker.\n */\nexport interface TickerPluginOptions\n{\n    /**\n     * Automatically starts the rendering after the construction.\n     *  **Note**: Setting this parameter to `false` does NOT stop the shared ticker even if you set\n     *  `options.sharedTicker` to `true` in case that it is already started. Stop it by your own.\n     * @memberof app.ApplicationOptions\n     * @default true\n     */\n    autoStart?: boolean;\n    /**\n     * Set`true` to use `Ticker.shared`, `false` to create new ticker.\n     *  If set to `false`, you cannot register a handler to occur before anything that runs on the shared ticker.\n     *  The system ticker will always run before both the shared ticker and the app ticker.\n     * @memberof app.ApplicationOptions\n     * @default false\n     */\n    sharedTicker?: boolean;\n}\n\n/**\n * Middleware for Application's {@link ticker.Ticker} functionality.\n *\n * Adds the following methods to {@link app.Application}:\n * * {@link app.Application#start}\n * * {@link app.Application#stop}\n * * {@link app.Application#ticker}\n * @example\n * import { extensions, TickerPlugin } from 'pixi.js';\n *\n * extensions.add(TickerPlugin);\n * @memberof app\n */\nexport class TickerPlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n\n    public static start: () => void;\n    public static stop: () => void;\n    private static _ticker: Ticker;\n    public static ticker: Ticker;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @static\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options?: PixiMixins.ApplicationOptions): void\n    {\n        // Set default\n        options = Object.assign({\n            autoStart: true,\n            sharedTicker: false,\n        }, options);\n\n        // Create ticker setter\n        Object.defineProperty(this, 'ticker',\n            {\n                set(ticker)\n                {\n                    if (this._ticker)\n                    {\n                        this._ticker.remove(this.render, this);\n                    }\n                    this._ticker = ticker;\n                    if (ticker)\n                    {\n                        ticker.add(this.render, this, UPDATE_PRIORITY.LOW);\n                    }\n                },\n                get()\n                {\n                    return this._ticker;\n                },\n            });\n\n        /**\n         * Convenience method for stopping the render.\n         * @method\n         * @memberof app.Application\n         * @instance\n         */\n        this.stop = (): void =>\n        {\n            this._ticker.stop();\n        };\n\n        /**\n         * Convenience method for starting the render.\n         * @method\n         * @memberof app.Application\n         * @instance\n         */\n        this.start = (): void =>\n        {\n            this._ticker.start();\n        };\n\n        /**\n         * Internal reference to the ticker.\n         * @type {Ticker}\n         * @name _ticker\n         * @memberof app.Application#\n         * @private\n         */\n        this._ticker = null;\n\n        /**\n         * Ticker for doing render updates.\n         * @type {ticker.Ticker}\n         * @name ticker\n         * @memberof app.Application#\n         * @default Ticker.shared\n         */\n        this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();\n\n        // Start the rendering\n        if (options.autoStart)\n        {\n            this.start();\n        }\n    }\n\n    /**\n     * Clean up the ticker, scoped to application.\n     * @static\n     * @private\n     */\n    public static destroy(): void\n    {\n        if (this._ticker)\n        {\n            const oldTicker = this._ticker;\n\n            this.ticker = null;\n            oldTicker.destroy();\n        }\n    }\n}\n","import { extensions } from '../extensions/Extensions';\nimport { ResizePlugin } from './ResizePlugin';\nimport { TickerPlugin } from './TickerPlugin';\n\nextensions.add(ResizePlugin);\nextensions.add(TickerPlugin);\n","import type { Matrix } from '../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableQuadElement } from '../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { Container } from '../container/Container';\n\n/**\n * A batchable sprite object.\n * @ignore\n */\nexport class BatchableSprite implements DefaultBatchableQuadElement\n{\n    public batcherName = 'default';\n    public topology: Topology = 'triangle-list';\n\n    // batch specific..\n    public readonly attributeSize = 4;\n    public readonly indexSize = 6;\n    public readonly packAsQuad = true;\n\n    public transform: Matrix;\n\n    public renderable: Container;\n    public texture: Texture;\n    public bounds: BoundsData;\n\n    public roundPixels: 0 | 1 = 0;\n\n    public _indexStart: number;\n    public _textureId: number;\n    public _attributeStart = 0; // location in the buffer\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n    get color() { return this.renderable.groupColorAlpha; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.bounds = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../gpu/colorToUniform';\nimport { BatchableGraphics } from './BatchableGraphics';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { BatchPipe, RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { RenderableGCSystem } from '../../../rendering/renderers/shared/texture/RenderableGCSystem';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Container } from '../../container/Container';\nimport type { Graphics } from './Graphics';\nimport type { GpuGraphicsContext, GraphicsContextSystem } from './GraphicsContextSystem';\n\nexport interface GraphicsAdaptor\n{\n    shader: Shader;\n    init(): void;\n    execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void;\n    destroy(): void;\n}\nexport interface GraphicsSystem\n{\n    graphicsContext: GraphicsContextSystem;\n    renderableGC: RenderableGCSystem;\n    renderPipes: {\n        batch: BatchPipe\n    }\n    _roundPixels: 0 | 1;\n}\n\nexport class GraphicsPipe implements RenderPipe<Graphics>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public renderer: GraphicsSystem;\n    public state: State = State.for2d();\n\n    // batchable graphics list, used to render batches\n    private _graphicsBatchesHash: Record<number, BatchableGraphics[]> = Object.create(null);\n    private _adaptor: GraphicsAdaptor;\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: GraphicsSystem, adaptor: GraphicsAdaptor)\n    {\n        this.renderer = renderer;\n\n        this._adaptor = adaptor;\n        this._adaptor.init();\n\n        this.renderer.renderableGC.addManagedHash(this, '_graphicsBatchesHash');\n    }\n\n    public validateRenderable(graphics: Graphics): boolean\n    {\n        // assume context is dirty..\n\n        const context = graphics.context;\n\n        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n\n        if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable)\n        {\n            // TODO what if they are the same size??\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // need to get batches here.. as we need to know if we can batch or not..\n        // this also overrides the current batches..\n\n        if (graphics.didViewUpdate)\n        {\n            this._rebuild(graphics);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._addToBatcher(graphics, instructionSet);\n        }\n        else\n        {\n            this.renderer.renderPipes.batch.break(instructionSet);\n            instructionSet.add(graphics);\n        }\n    }\n\n    public updateRenderable(graphics: Graphics)\n    {\n        const batches = this._graphicsBatchesHash[graphics.uid];\n\n        if (batches)\n        {\n            for (let i = 0; i < batches.length; i++)\n            {\n                const batch = batches[i];\n\n                batch._batcher.updateElement(batch);\n            }\n        }\n    }\n\n    public destroyRenderable(graphics: Graphics)\n    {\n        if (this._graphicsBatchesHash[graphics.uid])\n        {\n            this._removeBatchForRenderable(graphics.uid);\n        }\n\n        graphics.off('destroyed', this._destroyRenderableBound);\n    }\n\n    public execute(graphics: Graphics)\n    {\n        if (!graphics.isRenderable) return;\n\n        const renderer = this.renderer;\n        const context = graphics.context;\n        const contextSystem = renderer.graphicsContext;\n\n        // early out if there is no actual visual stuff...\n        if (!contextSystem.getGpuContext(context).batches.length)\n        { return; }\n\n        const shader = context.customShader || this._adaptor.shader;\n\n        this.state.blendMode = graphics.groupBlendMode;\n\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = graphics.groupTransform;\n        localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n\n        color32BitToUniform(\n            graphics.groupColorAlpha,\n            localUniforms.uColor,\n            0,\n        );\n\n        this._adaptor.execute(this, graphics);\n    }\n\n    private _rebuild(graphics: Graphics)\n    {\n        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // TODO POOL the old batches!\n\n        if (wasBatched)\n        {\n            this._removeBatchForRenderable(graphics.uid);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._initBatchesForRenderable(graphics);\n        }\n\n        graphics.batched = gpuContext.isBatchable;\n    }\n\n    private _addToBatcher(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const batchPipe = this.renderer.renderPipes.batch;\n\n        const batches = this._getBatchesForRenderable(graphics);\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batchPipe.addToBatch(batch, instructionSet);\n        }\n    }\n\n    private _getBatchesForRenderable(graphics: Graphics): BatchableGraphics[]\n    {\n        return this._graphicsBatchesHash[graphics.uid] || this._initBatchesForRenderable(graphics);\n    }\n\n    private _initBatchesForRenderable(graphics: Graphics): BatchableGraphics[]\n    {\n        const context = graphics.context;\n\n        const gpuContext: GpuGraphicsContext = this.renderer.graphicsContext.getGpuContext(context);\n\n        const roundPixels = (this.renderer._roundPixels | graphics._roundPixels) as 0 | 1;\n\n        const batches = gpuContext.batches.map((batch) =>\n        {\n            const batchClone = BigPool.get(BatchableGraphics);\n\n            batch.copyTo(batchClone);\n\n            batchClone.renderable = graphics;\n\n            batchClone.roundPixels = roundPixels;\n\n            return batchClone;\n        });\n\n        if (this._graphicsBatchesHash[graphics.uid] === undefined)\n        {\n            // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n            graphics.on('destroyed', this._destroyRenderableBound);\n        }\n\n        this._graphicsBatchesHash[graphics.uid] = batches;\n\n        return batches;\n    }\n\n    private _removeBatchForRenderable(graphicsUid: number)\n    {\n        this._graphicsBatchesHash[graphicsUid].forEach((batch) =>\n        {\n            BigPool.return(batch as PoolItem);\n        });\n\n        this._graphicsBatchesHash[graphicsUid] = null;\n    }\n\n    public destroy()\n    {\n        this.renderer = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n        this.state = null;\n\n        for (const i in this._graphicsBatchesHash)\n        {\n            this._removeBatchForRenderable(i as unknown as number);\n        }\n\n        this._graphicsBatchesHash = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { GraphicsContextSystem } from './shared/GraphicsContextSystem';\nimport { GraphicsPipe } from './shared/GraphicsPipe';\n\nextensions.add(GraphicsPipe);\nextensions.add(GraphicsContextSystem);\n","// TODO eventually we should not use this bit, but instead use the localUniformBit\n// have the MSDF bit be merged in with the localUniformBit\n\nexport const localUniformMSDFBit = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `,\n        main: /* wgsl */` \n            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));\n        `\n\n    }\n};\n\nexport const localUniformMSDFBitGl = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform float uDistance;\n         `,\n        main: /* glsl */` \n            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));\n        `\n\n    }\n};\n","export const mSDFBit = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* wgsl */`\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {\n                \n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n            \n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));\n                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);\n                var coverage: f32 = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n             \n            }\n        `,\n    }\n\n};\n\nexport const mSDFBitGl = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* glsl */`\n            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {\n                \n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n               \n                // SDF\n                median = min(median, msdfColor.a);\n            \n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n           \n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));\n                float gamma = mix(1.0, 1.0 / 2.2, luma);\n                float coverage = pow(shapeColor.a * alpha, gamma);  \n              \n                return coverage;\n            }\n        `,\n    }\n\n};\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { getMaxTexturesPerBatch } from '../../../rendering/batcher/gl/utils/maxRecommendedTextures';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBit, colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport {\n    generateTextureBatchBit,\n    generateTextureBatchBitGl\n} from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { getBatchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/getBatchSamplersUniformGroup';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { localUniformMSDFBit, localUniformMSDFBitGl } from './shader-bits/localUniformMSDFBit';\nimport { mSDFBit, mSDFBitGl } from './shader-bits/mSDFBit';\n\nimport type { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport type { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\n\nlet gpuProgram: GpuProgram;\nlet glProgram: GlProgram;\n\nexport class SdfShader extends Shader\n{\n    constructor()\n    {\n        const uniforms = new UniformGroup({\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uDistance: { value: 4, type: 'f32' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        const maxTextures = getMaxTexturesPerBatch();\n\n        gpuProgram ??= compileHighShaderGpuProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(maxTextures),\n                localUniformMSDFBit,\n                mSDFBit,\n                roundPixelsBit\n            ]\n        });\n\n        glProgram ??= compileHighShaderGlProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(maxTextures),\n                localUniformMSDFBitGl,\n                mSDFBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: uniforms,\n                batchSamplers: getBatchSamplersUniformGroup(maxTextures),\n            }\n        });\n    }\n}\n","import { Cache } from '../../assets/cache/Cache';\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { Graphics } from '../graphics/shared/Graphics';\nimport { SdfShader } from '../text/sdfShader/SdfShader';\nimport { BitmapFontManager } from './BitmapFontManager';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../rendering/renderers/shared/Renderable';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { Container } from '../container/Container';\nimport type { BitmapText } from './BitmapText';\n\nexport class BitmapTextPipe implements RenderPipe<BitmapText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'bitmapText',\n    } as const;\n\n    private _renderer: Renderer;\n    private _gpuBitmapText: Record<number, Graphics> = {};\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_gpuBitmapText');\n    }\n\n    public validateRenderable(bitmapText: BitmapText): boolean\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n\n        // TODO - need to shift all the verts in the graphicsData to the new anchor\n\n        // update the anchor...\n    }\n\n    public addRenderable(bitmapText: BitmapText, instructionSet: InstructionSet)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    public destroyRenderable(bitmapText: BitmapText)\n    {\n        bitmapText.off('destroyed', this._destroyRenderableBound);\n\n        this._destroyRenderableByUid(bitmapText.uid);\n    }\n\n    private _destroyRenderableByUid(renderableUid: number)\n    {\n        const context = this._gpuBitmapText[renderableUid].context;\n\n        if (context.customShader)\n        {\n            BigPool.return(context.customShader as PoolItem);\n\n            context.customShader = null;\n        }\n\n        BigPool.return(this._gpuBitmapText[renderableUid] as PoolItem);\n        this._gpuBitmapText[renderableUid] = null;\n    }\n\n    public updateRenderable(bitmapText: BitmapText)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    private _updateContext(bitmapText: BitmapText, proxyGraphics: Graphics)\n    {\n        const { context } = proxyGraphics;\n\n        const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n\n        context.clear();\n\n        if (bitmapFont.distanceField.type !== 'none')\n        {\n            if (!context.customShader)\n            {\n                context.customShader = BigPool.get(SdfShader);\n            }\n        }\n\n        const chars = Array.from(bitmapText.text);\n        const style = bitmapText._style;\n\n        let currentY = bitmapFont.baseLineOffset;\n\n        // measure our text...\n        const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont, true);\n\n        let index = 0;\n\n        const padding = style.padding;\n        const scale = bitmapTextLayout.scale;\n\n        let tx = bitmapTextLayout.width;\n        let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;\n\n        if (style._stroke)\n        {\n            tx += style._stroke.width / scale;\n            ty += style._stroke.width / scale;\n        }\n\n        context\n            .translate((-bitmapText._anchor._x * tx) - padding, (-bitmapText._anchor._y * ty) - padding)\n            .scale(scale, scale);\n\n        const tint = bitmapFont.applyFillAsTint ? style._fill.color : 0xFFFFFF;\n\n        for (let i = 0; i < bitmapTextLayout.lines.length; i++)\n        {\n            const line = bitmapTextLayout.lines[i];\n\n            for (let j = 0; j < line.charPositions.length; j++)\n            {\n                const char = chars[index++];\n\n                const charData = bitmapFont.chars[char];\n\n                if (charData?.texture)\n                {\n                    context.texture(\n                        charData.texture,\n                        tint ? tint : 'black',\n                        Math.round(line.charPositions[j] + charData.xOffset),\n                        Math.round(currentY + charData.yOffset),\n                    );\n                }\n            }\n\n            currentY += bitmapFont.lineHeight;\n        }\n    }\n\n    private _getGpuBitmapText(bitmapText: BitmapText)\n    {\n        return this._gpuBitmapText[bitmapText.uid] || this.initGpuText(bitmapText);\n    }\n\n    public initGpuText(bitmapText: BitmapText)\n    {\n        // TODO we could keep a bunch of contexts around and reuse one that has the same style!\n        const proxyRenderable = BigPool.get(Graphics);\n\n        this._gpuBitmapText[bitmapText.uid] = proxyRenderable;\n\n        this._updateContext(bitmapText, proxyRenderable);\n\n        bitmapText.on('destroyed', this._destroyRenderableBound);\n\n        return this._gpuBitmapText[bitmapText.uid];\n    }\n\n    private _updateDistanceField(bitmapText: BitmapText)\n    {\n        const context = this._getGpuBitmapText(bitmapText).context;\n\n        const fontFamily = bitmapText._style.fontFamily as string;\n        const dynamicFont = Cache.get(`${fontFamily as string}-bitmap`);\n\n        // Inject the shader code with the correct value\n        const { a, b, c, d } = bitmapText.groupTransform;\n\n        const dx = Math.sqrt((a * a) + (b * b));\n        const dy = Math.sqrt((c * c) + (d * d));\n        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n\n        const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n\n        const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale);\n\n        context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n    }\n\n    public destroy()\n    {\n        for (const uid in this._gpuBitmapText)\n        {\n            this._destroyRenderableByUid(uid as unknown as number);\n        }\n\n        this._gpuBitmapText = null;\n\n        this._renderer = null;\n    }\n}\n\nfunction syncWithProxy(container: Renderable, proxy: Renderable)\n{\n    proxy.groupTransform = container.groupTransform;\n    proxy.groupColorAlpha = container.groupColorAlpha;\n    proxy.groupColor = container.groupColor;\n    proxy.groupBlendMode = container.groupBlendMode;\n    proxy.globalDisplayStatus = container.globalDisplayStatus;\n    proxy.groupTransform = container.groupTransform;\n    proxy.localDisplayStatus = container.localDisplayStatus;\n    proxy.groupAlpha = container.groupAlpha;\n    proxy._roundPixels = container._roundPixels;\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { BitmapTextPipe } from './BitmapTextPipe';\n\nextensions.add(BitmapTextPipe);\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../../sprite/BatchableSprite';\nimport { updateTextBounds } from '../utils/updateTextBounds';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Container } from '../../container/Container';\nimport type { Text } from '../Text';\n\nexport class CanvasTextPipe implements RenderPipe<Text>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'text',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _gpuText: Record<number, {\n        texture: Texture,\n        currentKey: string,\n        batchableSprite: BatchableSprite,\n    }> = Object.create(null);\n\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.runners.resolutionChange.add(this);\n        this._renderer.renderableGC.addManagedHash(this, '_gpuText');\n    }\n\n    public resolutionChange()\n    {\n        for (const i in this._gpuText)\n        {\n            const gpuText = this._gpuText[i];\n\n            if (!gpuText) continue;\n\n            const text = gpuText.batchableSprite.renderable as Text;\n\n            if (text._autoResolution)\n            {\n                text._resolution = this._renderer.resolution;\n                text.onViewUpdate();\n            }\n        }\n    }\n\n    public validateRenderable(text: Text): boolean\n    {\n        const gpuText = this._getGpuText(text);\n\n        const newKey = text._getKey();\n\n        if (gpuText.currentKey !== newKey)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(text: Text, instructionSet: InstructionSet)\n    {\n        const gpuText = this._getGpuText(text);\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (text._didTextUpdate)\n        {\n            this._updateText(text);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableSprite, instructionSet);\n    }\n\n    public updateRenderable(text: Text)\n    {\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (text._didTextUpdate)\n        {\n            this._updateText(text);\n        }\n\n        batchableSprite._batcher.updateElement(batchableSprite);\n    }\n\n    public destroyRenderable(text: Text)\n    {\n        text.off('destroyed', this._destroyRenderableBound);\n\n        this._destroyRenderableById(text.uid);\n    }\n\n    private _destroyRenderableById(textUid: number)\n    {\n        const gpuText = this._gpuText[textUid];\n\n        this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n\n        BigPool.return(gpuText.batchableSprite);\n\n        this._gpuText[textUid] = null;\n    }\n\n    private _updateText(text: Text)\n    {\n        const newKey = text._getKey();\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            this._updateGpuText(text);\n        }\n\n        text._didTextUpdate = false;\n\n        updateTextBounds(batchableSprite, text);\n    }\n\n    private _updateGpuText(text: Text)\n    {\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.texture)\n        {\n            this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n        }\n\n        gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getManagedTexture(text);\n        gpuText.currentKey = text._getKey();\n        batchableSprite.texture = gpuText.texture;\n    }\n\n    private _getGpuText(text: Text)\n    {\n        return this._gpuText[text.uid] || this.initGpuText(text);\n    }\n\n    public initGpuText(text: Text)\n    {\n        const gpuTextData: CanvasTextPipe['_gpuText'][number] = {\n            texture: null,\n            currentKey: '--',\n            batchableSprite: BigPool.get(BatchableSprite),\n        };\n\n        gpuTextData.batchableSprite.renderable = text;\n        gpuTextData.batchableSprite.transform = text.groupTransform;\n        gpuTextData.batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        gpuTextData.batchableSprite.roundPixels = (this._renderer._roundPixels | text._roundPixels) as 0 | 1;\n\n        this._gpuText[text.uid] = gpuTextData;\n\n        text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n        this._updateText(text);\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        text.on('destroyed', this._destroyRenderableBound);\n\n        return gpuTextData;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuText)\n        {\n            this._destroyRenderableById(i as unknown as number);\n        }\n\n        this._gpuText = null;\n        this._renderer = null;\n    }\n}\n","import { Rectangle } from '../../maths/shapes/Rectangle';\n\nimport type { ICanvas } from '../../environment/canvas/ICanvas';\n\nfunction checkRow(data: Uint8ClampedArray, width: number, y: number)\n{\n    for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\nfunction checkColumn(data: Uint8ClampedArray, width: number, x: number, top: number, bottom: number)\n{\n    const stride = 4 * width;\n\n    for (let y = top, index = (top * stride) + (4 * x); y <= bottom; ++y, index += stride)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\n/**\n * Measuring the bounds of a canvas' visible (non-transparent) pixels.\n * @param canvas - The canvas to measure.\n * @param resolution - The resolution of the canvas.\n * @returns The bounding box of the canvas' visible pixels.\n * @since 7.1.0\n * @memberof utils\n */\nexport function getCanvasBoundingBox(canvas: ICanvas, resolution = 1): Rectangle\n{\n    // https://gist.github.com/timdown/021d9c8f2aabc7092df564996f5afbbf\n\n    const { width, height } = canvas;\n\n    const context = canvas.getContext('2d', {\n        willReadFrequently: true,\n    });\n\n    if (context === null)\n    {\n        throw new TypeError('Failed to get canvas 2D context');\n    }\n\n    const imageData = context.getImageData(0, 0, width, height);\n    const data = imageData.data;\n\n    let left = 0;\n    let top = 0;\n    let right = width - 1;\n    let bottom = height - 1;\n\n    while (top < height && checkRow(data, width, top)) ++top;\n    if (top === height) return Rectangle.EMPTY;\n    while (checkRow(data, width, bottom)) --bottom;\n    while (checkColumn(data, width, left, top, bottom)) ++left;\n    while (checkColumn(data, width, right, top, bottom)) --right;\n\n    ++right;\n    ++bottom;\n\n    return new Rectangle(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);\n}\n","import { Color } from '../../../color/Color';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { nextPow2 } from '../../../maths/misc/pow2';\nimport { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { getCanvasBoundingBox } from '../../../utils/canvas/getCanvasBoundingBox';\nimport { deprecation } from '../../../utils/logging/deprecation';\nimport { TextStyle } from '../TextStyle';\nimport { getPo2TextureFromSource } from '../utils/getPo2TextureFromSource';\nimport { CanvasTextMetrics } from './CanvasTextMetrics';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from './utils/getCanvasFillStyle';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { TextOptions } from '../AbstractText';\nimport type { Text } from '../Text';\n\ninterface CanvasAndContext\n{\n    canvas: ICanvas;\n    context: ICanvasRenderingContext2D;\n}\n\n/**\n * System plugin to the renderer to manage canvas text.\n * @memberof rendering\n */\nexport class CanvasTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'canvasText',\n    } as const;\n\n    private _activeTextures: Record<string, {\n        canvasAndContext: CanvasAndContext,\n        texture: Texture,\n        usageCount: number,\n    }> = {};\n\n    private readonly _renderer: Renderer;\n\n    constructor(_renderer: Renderer)\n    {\n        this._renderer = _renderer;\n    }\n\n    public getTextureSize(text: string, resolution: number, style: TextStyle): { width: number, height: number }\n    {\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        let width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        let height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        width = Math.ceil((width) - 1e-6);\n        height = Math.ceil((height) - 1e-6);\n        width = nextPow2(width);\n        height = nextPow2(height);\n\n        return { width, height };\n    }\n\n    /**\n     * This is a function that will create a texture from a text string, style and resolution.\n     * Useful if you want to make a texture of your text and use if for various other pixi things!\n     * @param options - The options of the text that will be used to generate the texture.\n     * @param options.text - the text to render\n     * @param options.style - the style of the text\n     * @param options.resolution - the resolution of the texture\n     * @returns the newly created texture\n     */\n    /** @deprecated since 8.0.0 */\n    public getTexture(text: string, resolution: number, style: TextStyle, textKey: string): Texture;\n    public getTexture(options: TextOptions): Texture;\n    public getTexture(options: TextOptions | string, resolution?: number, style?: TextStyle, _textKey?: string): Texture\n    {\n        if (typeof options === 'string')\n        {\n            // #if _DEBUG\n            deprecation('8.0.0', 'CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments');\n            // #endif\n\n            options = {\n                text: options,\n                style,\n                resolution,\n            };\n        }\n\n        if (!(options.style instanceof TextStyle))\n        {\n            options.style = new TextStyle(options.style);\n        }\n\n        const { texture, canvasAndContext } = this.createTextureAndCanvas(\n            options as {text: string, style: TextStyle, resolution?: number}\n        );\n\n        this._renderer.texture.initSource(texture._source);\n\n        CanvasPool.returnCanvasAndContext(canvasAndContext);\n\n        return texture;\n    }\n\n    public createTextureAndCanvas(options: {text: string, style: TextStyle, resolution?: number})\n    {\n        const { text, style } = options;\n\n        const resolution = options.resolution ?? this._renderer.resolution;\n\n        // create a canvas with the word hello on it\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);\n\n        // create a texture from the canvas\n        const { canvas } = canvasAndContext;\n\n        this.renderTextToCanvas(text, style, resolution, canvasAndContext);\n\n        const texture = getPo2TextureFromSource(canvas, width, height, resolution);\n\n        if (style.trim)\n        {\n            const trimmed = getCanvasBoundingBox(canvas, resolution);\n\n            texture.frame.copyFrom(trimmed);\n\n            texture.updateUvs();\n        }\n\n        return { texture, canvasAndContext };\n    }\n\n    public getManagedTexture(text: Text)\n    {\n        text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n        const textKey = text._getKey();\n\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].texture;\n        }\n\n        const { texture, canvasAndContext } = this.createTextureAndCanvas(text);\n\n        this._activeTextures[textKey] = {\n            canvasAndContext,\n            texture,\n            usageCount: 1,\n        };\n\n        return texture;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    /**\n     * Returns a texture that was created wit the above `getTexture` function.\n     * Handy if you are done with a texture and want to return it to the pool.\n     * @param texture - The texture to be returned.\n     */\n    public returnTexture(texture: Texture)\n    {\n        const source = texture.source;\n\n        source.resource = null;\n        source.uploadMethodId = 'unknown';\n        source.alphaMode = 'no-premultiply-alpha';\n\n        TexturePool.returnTexture(texture);\n    }\n\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            CanvasPool.returnCanvasAndContext(activeTexture.canvasAndContext);\n\n            this.returnTexture(activeTexture.texture);\n\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey].usageCount;\n    }\n\n    /**\n     * Renders text to its canvas, and updates its texture.\n     *\n     * By default this is used internally to ensure the texture is correct before rendering,\n     * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,\n     * and then shared across multiple Sprites.\n     * @param text\n     * @param style\n     * @param resolution\n     * @param canvasAndContext\n     */\n    public renderTextToCanvas(text: string, style: TextStyle, resolution: number, canvasAndContext: CanvasAndContext): void\n    {\n        const { canvas, context } = canvasAndContext;\n\n        const font = fontStringFromTextStyle(style);\n\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);// , canvas);\n        const lines = measured.lines;\n        const lineHeight = measured.lineHeight;\n        const lineWidths = measured.lineWidths;\n        const maxLineWidth = measured.maxLineWidth;\n        const fontProperties = measured.fontProperties;\n\n        const height = canvas.height;\n\n        context.resetTransform();\n        context.scale(resolution, resolution);\n        context.textBaseline = style.textBaseline;\n\n        // set stroke styles..\n\n        if (style._stroke?.width)\n        {\n            const strokeStyle = style._stroke;\n\n            context.lineWidth = strokeStyle.width;\n\n            context.miterLimit = strokeStyle.miterLimit;\n            context.lineJoin = strokeStyle.join;\n            context.lineCap = strokeStyle.cap;\n        }\n\n        // return;\n        context.font = font;\n\n        let linePositionX: number;\n        let linePositionY: number;\n\n        // require 2 passes if a shadow; the first to draw the drop shadow, the second to draw the text\n        const passesCount = style.dropShadow ? 2 : 1;\n\n        // For v4, we drew text at the colours of the drop shadow underneath the normal text. This gave the correct zIndex,\n        // but features such as alpha and shadowblur did not look right at all, since we were using actual text as a shadow.\n        //\n        // For v5.0.0, we moved over to just use the canvas API for drop shadows, which made them look much nicer and more\n        // visually please, but now because the stroke is drawn and then the fill, drop shadows would appear on both the fill\n        // and the stroke; and fill drop shadows would appear over the top of the stroke.\n        //\n        // For v5.1.1, the new route is to revert to v4 style of drawing text first to get the drop shadows underneath normal\n        // text, but instead drawing text in the correct location, we'll draw it off screen (-paddingY), and then adjust the\n        // drop shadow so only that appears on screen (+paddingY). Now we'll have the correct draw order of the shadow\n        // beneath the text, whilst also having the proper text shadow styling.\n        for (let i = 0; i < passesCount; ++i)\n        {\n            const isShadowPass = style.dropShadow && i === 0;\n            // we only want the drop shadow, so put text way off-screen\n            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + (style.padding * 2)) : 0;\n            const dsOffsetShadow = dsOffsetText * resolution;\n\n            if (isShadowPass)\n            {\n                // On Safari, text with gradient and drop shadows together do not position correctly\n                // if the scale of the canvas is not 1: https://bugs.webkit.org/show_bug.cgi?id=197689\n                // Therefore we'll set the styles to be a plain black whilst generating this drop shadow\n                context.fillStyle = 'black';\n                context.strokeStyle = 'black';\n\n                const shadowOptions = style.dropShadow;\n\n                const dropShadowColor = shadowOptions.color;\n                const dropShadowAlpha = shadowOptions.alpha;\n\n                context.shadowColor = Color.shared\n                    .setValue(dropShadowColor)\n                    .setAlpha(dropShadowAlpha)\n                    .toRgbaString();\n\n                const dropShadowBlur = shadowOptions.blur * resolution;\n                const dropShadowDistance = shadowOptions.distance * resolution;\n\n                context.shadowBlur = dropShadowBlur;\n                context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n                context.shadowOffsetY = (Math.sin(shadowOptions.angle) * dropShadowDistance) + dsOffsetShadow;\n            }\n            else\n            {\n                context.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context, measured) : null;\n\n                if (style._stroke?.width)\n                {\n                    const padding = style._stroke.width * style._stroke.alignment;\n\n                    context.strokeStyle = getCanvasFillStyle(style._stroke, context, measured, padding);\n                }\n\n                context.shadowColor = 'black';\n            }\n\n            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n\n            if (lineHeight - fontProperties.fontSize < 0)\n            {\n                linePositionYShift = 0;\n            }\n\n            const strokeWidth = style._stroke?.width ?? 0;\n\n            // draw lines line by line\n            for (let i = 0; i < lines.length; i++)\n            {\n                linePositionX = strokeWidth / 2;\n                linePositionY = ((strokeWidth / 2) + (i * lineHeight)) + fontProperties.ascent + linePositionYShift;\n\n                if (style.align === 'right')\n                {\n                    linePositionX += maxLineWidth - lineWidths[i];\n                }\n                else if (style.align === 'center')\n                {\n                    linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n                }\n\n                if (style._stroke?.width)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText,\n                        true\n                    );\n                }\n\n                if (style._fill !== undefined)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Render the text with letter-spacing.\n     * @param text - The text to draw\n     * @param style\n     * @param canvasAndContext\n     * @param x - Horizontal position to draw the text\n     * @param y - Vertical position to draw the text\n     * @param isStroke - Is this drawing for the outside stroke of the\n     *  text? If not, it's for the inside fill\n     */\n    private _drawLetterSpacing(\n        text: string,\n        style: TextStyle,\n        canvasAndContext: CanvasAndContext,\n        x: number, y: number,\n        isStroke = false\n    ): void\n    {\n        const { context } = canvasAndContext;\n\n        // letterSpacing of 0 means normal\n        const letterSpacing = style.letterSpacing;\n\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        if (letterSpacing === 0 || useExperimentalLetterSpacing)\n        {\n            if (isStroke)\n            {\n                context.strokeText(text, x, y);\n            }\n            else\n            {\n                context.fillText(text, x, y);\n            }\n\n            return;\n        }\n\n        let currentPosition = x;\n\n        const stringArray = CanvasTextMetrics.graphemeSegmenter(text);\n        let previousWidth = context.measureText(text).width;\n        let currentWidth = 0;\n\n        for (let i = 0; i < stringArray.length; ++i)\n        {\n            const currentChar = stringArray[i];\n\n            if (isStroke)\n            {\n                context.strokeText(currentChar, currentPosition, y);\n            }\n            else\n            {\n                context.fillText(currentChar, currentPosition, y);\n            }\n            let textStr = '';\n\n            for (let j = i + 1; j < stringArray.length; ++j)\n            {\n                textStr += stringArray[j];\n            }\n            currentWidth = context.measureText(textStr).width;\n            currentPosition += previousWidth - currentWidth + letterSpacing;\n            previousWidth = currentWidth;\n        }\n    }\n\n    public destroy(): void\n    {\n        this._activeTextures = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { CanvasTextPipe } from './canvas/CanvasTextPipe';\nimport { CanvasTextSystem } from './canvas/CanvasTextSystem';\n\nextensions.add(CanvasTextSystem);\nextensions.add(CanvasTextPipe);\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from './BatchableMesh';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type {\n    InstructionPipe,\n    RenderPipe\n} from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Container } from '../../container/Container';\nimport type { Mesh } from './Mesh';\n\n// TODO Record mode is a P2, will get back to this as it's not a priority\n// const recordMode = true;\n\ninterface MeshData\n{\n    batched: boolean;\n    indexSize: number;\n    vertexSize: number;\n}\n\nexport interface MeshAdaptor\n{\n    init(): void;\n    execute(meshPipe: MeshPipe, mesh: Mesh): void;\n    destroy(): void;\n}\n\nexport class MeshPipe implements RenderPipe<Mesh>, InstructionPipe<Mesh>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'mesh',\n    } as const;\n\n    public localUniforms = new UniformGroup({\n        uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n        uRound: { value: 0, type: 'f32' },\n    });\n\n    public localUniformsBindGroup = new BindGroup({\n        0: this.localUniforms,\n    });\n\n    public renderer: Renderer;\n\n    private _meshDataHash: Record<number, MeshData> = Object.create(null);\n    private _gpuBatchableMeshHash: Record<number, BatchableMesh> = Object.create(null);\n    private _adaptor: MeshAdaptor;\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer, adaptor: MeshAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init();\n\n        renderer.renderableGC.addManagedHash(this, '_gpuBatchableMeshHash');\n        renderer.renderableGC.addManagedHash(this, '_meshDataHash');\n    }\n\n    public validateRenderable(mesh: Mesh): boolean\n    {\n        const meshData = this._getMeshData(mesh);\n\n        const wasBatched = meshData.batched;\n\n        const isBatched = mesh.batched;\n\n        meshData.batched = isBatched;\n\n        if (wasBatched !== isBatched)\n        {\n            return true;\n        }\n        else if (isBatched)\n        {\n            const geometry = mesh._geometry;\n\n            // no need to break the batch if it's the same size\n            if (geometry.indices.length !== meshData.indexSize\n                    || geometry.positions.length !== meshData.vertexSize)\n            {\n                meshData.indexSize = geometry.indices.length;\n                meshData.vertexSize = geometry.positions.length;\n\n                return true;\n            }\n\n            const batchableMesh = this._getBatchableMesh(mesh);\n\n            if (batchableMesh.texture.uid !== mesh._texture.uid)\n            {\n                batchableMesh._textureMatrixUpdateId = -1;\n            }\n\n            return !batchableMesh._batcher.checkAndUpdateTexture(\n                batchableMesh,\n                mesh._texture\n            );\n        }\n\n        return false;\n    }\n\n    public addRenderable(mesh: Mesh, instructionSet: InstructionSet)\n    {\n        const batcher = this.renderer.renderPipes.batch;\n\n        const { batched } = this._getMeshData(mesh);\n\n        if (batched)\n        {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n\n            gpuBatchableMesh.setTexture(mesh._texture);\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            batcher.addToBatch(gpuBatchableMesh, instructionSet);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            instructionSet.add(mesh);\n        }\n    }\n\n    public updateRenderable(mesh: Mesh)\n    {\n        if (mesh.batched)\n        {\n            const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];\n\n            gpuBatchableMesh.setTexture(mesh._texture);\n\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);\n        }\n    }\n\n    public destroyRenderable(mesh: Mesh)\n    {\n        this._meshDataHash[mesh.uid] = null;\n\n        const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];\n\n        if (gpuMesh)\n        {\n            BigPool.return(gpuMesh as PoolItem);\n            this._gpuBatchableMeshHash[mesh.uid] = null;\n        }\n\n        mesh.off('destroyed', this._destroyRenderableBound);\n    }\n\n    public execute(mesh: Mesh)\n    {\n        if (!mesh.isRenderable) return;\n\n        mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);\n\n        const localUniforms = this.localUniforms;\n\n        localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n        localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n        localUniforms.update();\n\n        color32BitToUniform(\n            mesh.groupColorAlpha,\n            localUniforms.uniforms.uColor,\n            0\n        );\n\n        this._adaptor.execute(this, mesh);\n    }\n\n    private _getMeshData(mesh: Mesh): MeshData\n    {\n        return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);\n    }\n\n    private _initMeshData(mesh: Mesh): MeshData\n    {\n        this._meshDataHash[mesh.uid] = {\n            batched: mesh.batched,\n            indexSize: mesh._geometry.indices?.length,\n            vertexSize: mesh._geometry.positions?.length,\n        };\n\n        mesh.on('destroyed', this._destroyRenderableBound);\n\n        return this._meshDataHash[mesh.uid];\n    }\n\n    private _getBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);\n    }\n\n    private _initBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        // TODO - make this batchable graphics??\n        const gpuMesh: BatchableMesh = BigPool.get(BatchableMesh);\n\n        gpuMesh.renderable = mesh;\n        gpuMesh.setTexture(mesh._texture);\n        gpuMesh.transform = mesh.groupTransform;\n        gpuMesh.roundPixels = (this.renderer._roundPixels | mesh._roundPixels) as 0 | 1;\n\n        this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;\n\n        return gpuMesh;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuBatchableMeshHash)\n        {\n            if (this._gpuBatchableMeshHash[i])\n            {\n                BigPool.return(this._gpuBatchableMeshHash[i] as PoolItem);\n            }\n        }\n\n        this._gpuBatchableMeshHash = null;\n        this._meshDataHash = null;\n\n        this.localUniforms = null;\n        this.localUniformsBindGroup = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n\n        this.renderer = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { MeshPipe } from './shared/MeshPipe';\n\nextensions.add(MeshPipe);\n","import { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { Bounds } from '../../container/bounds/Bounds';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nconst tempBounds = new Bounds();\n\n/**\n * Takes an image and creates a texture from it, using a power of 2 texture from the texture pool.\n * Remember to return the texture when you don't need it any more!\n * @param image - The image to create a texture from\n * @param width - the frame width of the texture\n * @param height - the frame height of the texture\n * @param resolution - The resolution of the texture\n * @returns - The texture\n */\nexport function getPo2TextureFromSource(\n    image: HTMLImageElement | HTMLCanvasElement | ICanvas,\n    width: number,\n    height: number,\n    resolution: number\n): Texture\n{\n    const bounds = tempBounds;\n\n    bounds.minX = 0;\n    bounds.minY = 0;\n\n    bounds.maxX = (image.width / resolution) | 0;\n    bounds.maxY = (image.height / resolution) | 0;\n\n    const texture = TexturePool.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        resolution,\n        false\n    );\n\n    texture.source.uploadMethodId = 'image';\n    texture.source.resource = image;\n    texture.source.alphaMode = 'premultiply-alpha-on-upload';\n\n    texture.frame.width = width / resolution;\n    texture.frame.height = height / resolution;\n\n    // We want to update the resource on the GPU,\n    // but we do not want to resize the texture.\n    // calling `texture.source.update` will fit the resource to the texture\n    // causing a resize of the texture on the GPU.\n    // which is not what we want!\n    texture.source.emit('update', texture.source);\n\n    texture.updateUvs();\n\n    return texture;\n}\n","import { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\n\nimport type { MeshGeometryOptions } from '../mesh/shared/MeshGeometry';\n\n/**\n * Constructor options used for `PlaneGeometry` instances.\n * ```js\n * const planeGeometry = new PlaneGeometry({\n *    width: 100,\n *    height: 100,\n *    verticesX: 10,\n *    verticesY: 10,\n * });\n * ```\n * @see {@link scene.PlaneGeometry}\n * @memberof scene\n */\nexport interface PlaneGeometryOptions\n{\n    /** Width of plane */\n    width?: number;\n    /** Height of plane */\n    height?: number;\n    /** Number of vertices on x-axis */\n    verticesX?: number;\n    /** Number of vertices on y-axis */\n    verticesY?: number;\n}\n\n/**\n * The PlaneGeometry allows you to draw a 2d plane\n * @memberof scene\n */\nexport class PlaneGeometry extends MeshGeometry\n{\n    public static defaultOptions: PlaneGeometryOptions & MeshGeometryOptions = {\n        width: 100,\n        height: 100,\n        verticesX: 10,\n        verticesY: 10,\n    };\n\n    /** The number of vertices on x-axis */\n    public verticesX: number;\n    /** The number of vertices on y-axis */\n    public verticesY: number;\n    /** The width of plane */\n    public width: number;\n    /** The height of plane */\n    public height: number;\n\n    /**\n     * @param {PlaneGeometryOptions} options - Options to be applied to plane geometry\n     */\n    constructor(options: PlaneGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(width?: number, height?: number, verticesX?: number, verticesY?: number);\n    constructor(...args: [PlaneGeometryOptions?] | [number?, number?, number?, number?])\n    {\n        super({});\n\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number')\n        {\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead');\n            // #endif\n\n            options = {\n                width: options,\n                height: args[1],\n                verticesX: args[2],\n                verticesY: args[3],\n            };\n        }\n\n        this.build(options);\n    }\n\n    /**\n     * Refreshes plane coordinates\n     * @param options - Options to be applied to plane geometry\n     */\n    public build(options: PlaneGeometryOptions): void\n    {\n        options = { ...PlaneGeometry.defaultOptions, ...options };\n\n        this.verticesX = this.verticesX ?? options.verticesX;\n        this.verticesY = this.verticesY ?? options.verticesY;\n\n        this.width = this.width ?? options.width;\n        this.height = this.height ?? options.height;\n\n        const total = this.verticesX * this.verticesY;\n        const verts = [];\n        const uvs = [];\n        const indices = [];\n\n        const verticesX = this.verticesX - 1;\n        const verticesY = this.verticesY - 1;\n\n        const sizeX = (this.width) / verticesX;\n        const sizeY = (this.height) / verticesY;\n\n        for (let i = 0; i < total; i++)\n        {\n            const x = (i % this.verticesX);\n            const y = ((i / this.verticesX) | 0);\n\n            verts.push(x * sizeX, y * sizeY);\n            uvs.push(x / verticesX, y / verticesY);\n        }\n\n        const totalSub = verticesX * verticesY;\n\n        for (let i = 0; i < totalSub; i++)\n        {\n            const xpos = i % verticesX;\n            const ypos = (i / verticesX) | 0;\n\n            const value = (ypos * this.verticesX) + xpos;\n            const value2 = (ypos * this.verticesX) + xpos + 1;\n            const value3 = ((ypos + 1) * this.verticesX) + xpos;\n            const value4 = ((ypos + 1) * this.verticesX) + xpos + 1;\n\n            indices.push(value, value2, value3,\n                value2, value4, value3);\n        }\n\n        this.buffers[0].data = new Float32Array(verts);\n        this.buffers[1].data = new Float32Array(uvs);\n        this.indexBuffer.data = new Uint32Array(indices);\n\n        // ensure that the changes are uploaded\n        this.buffers[0].update();\n        this.buffers[1].update();\n        this.indexBuffer.update();\n    }\n}\n","import { PlaneGeometry } from '../mesh-plane/PlaneGeometry';\nimport { type PointData } from '~/maths/point/PointData';\n\n/**\n * Options for the NineSliceGeometry.\n * @memberof scene\n */\nexport interface NineSliceGeometryOptions\n{\n\n    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    width?: number\n    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    height?: number\n    /** The original width of the texture */\n    originalWidth?: number\n    /** The original height of the texture */\n    originalHeight?: number\n    /** The width of the left column. */\n    leftWidth?: number\n    /** The height of the top row. */\n    topHeight?: number\n    /** The width of the right column. */\n    rightWidth?: number\n    /** The height of the bottom row. */\n    bottomHeight?: number\n\n    /** The anchor point of the NineSliceSprite. */\n    anchor?: PointData\n}\n\n/**\n * The NineSliceGeometry class allows you to create a NineSlicePlane object.\n * @memberof scene\n */\nexport class NineSliceGeometry extends PlaneGeometry\n{\n    /** The default options for the NineSliceGeometry. */\n    public static defaultOptions: NineSliceGeometryOptions = {\n        /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        width: 100,\n        /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        height: 100,\n        /** The width of the left column. */\n        leftWidth: 10,\n        /** The height of the top row. */\n        topHeight: 10,\n        /** The width of the right column. */\n        rightWidth: 10,\n        /** The height of the bottom row. */\n        bottomHeight: 10,\n\n        /** The original width of the texture */\n        originalWidth: 100,\n        /** The original height of the texture */\n        originalHeight: 100,\n    };\n\n    public _leftWidth: number;\n    public _rightWidth: number;\n    public _topHeight: number;\n    public _bottomHeight: number;\n\n    private _originalWidth: number;\n    private _originalHeight: number;\n    private _anchorX: any;\n    private _anchorY: number;\n\n    constructor(options: NineSliceGeometryOptions = {})\n    {\n        options = { ...NineSliceGeometry.defaultOptions, ...options };\n\n        super({\n            width: options.width,\n            height: options.height,\n            verticesX: 4,\n            verticesY: 4,\n        });\n\n        this.update(options);\n    }\n\n    /**\n     * Updates the NineSliceGeometry with the options.\n     * @param options - The options of the NineSliceGeometry.\n     */\n    public update(options: NineSliceGeometryOptions)\n    {\n        this.width = options.width ?? this.width;\n        this.height = options.height ?? this.height;\n        this._originalWidth = options.originalWidth ?? this._originalWidth;\n        this._originalHeight = options.originalHeight ?? this._originalHeight;\n        this._leftWidth = options.leftWidth ?? this._leftWidth;\n        this._rightWidth = options.rightWidth ?? this._rightWidth;\n        this._topHeight = options.topHeight ?? this._topHeight;\n        this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n\n        this._anchorX = options.anchor?.x;\n        this._anchorY = options.anchor?.y;\n\n        this.updateUvs();\n        this.updatePositions();\n    }\n\n    /** Updates the positions of the vertices. */\n    public updatePositions()\n    {\n        const p = this.positions;\n        const {\n            width,\n            height,\n            _leftWidth,\n            _rightWidth,\n            _topHeight,\n            _bottomHeight,\n            _anchorX,\n            _anchorY,\n        } = this;\n\n        const w = _leftWidth + _rightWidth;\n        const scaleW = width > w ? 1.0 : width / w;\n\n        const h = _topHeight + _bottomHeight;\n        const scaleH = height > h ? 1.0 : height / h;\n\n        const scale = Math.min(scaleW, scaleH);\n\n        const anchorOffsetX = _anchorX * width;\n        const anchorOffsetY = _anchorY * height;\n\n        p[0] = p[8] = p[16] = p[24] = -anchorOffsetX;\n        p[2] = p[10] = p[18] = p[26] = (_leftWidth * scale) - anchorOffsetX;\n        p[4] = p[12] = p[20] = p[28] = width - (_rightWidth * scale) - anchorOffsetX;\n        p[6] = p[14] = p[22] = p[30] = width - anchorOffsetX;\n\n        p[1] = p[3] = p[5] = p[7] = -anchorOffsetY;\n        p[9] = p[11] = p[13] = p[15] = (_topHeight * scale) - anchorOffsetY;\n        p[17] = p[19] = p[21] = p[23] = height - (_bottomHeight * scale) - anchorOffsetY;\n        p[25] = p[27] = p[29] = p[31] = height - anchorOffsetY;\n\n        this.getBuffer('aPosition').update();\n    }\n\n    /** Updates the UVs of the vertices. */\n    public updateUvs()\n    {\n        const uvs = this.uvs;\n\n        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n\n        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n\n        const _uvw = 1.0 / this._originalWidth;\n        const _uvh = 1.0 / this._originalHeight;\n\n        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n\n        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - (_uvw * this._rightWidth);\n        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - (_uvh * this._bottomHeight);\n\n        this.getBuffer('aUV').update();\n    }\n}\n\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { NineSliceGeometry } from './NineSliceGeometry';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { Container } from '../container/Container';\nimport type { NineSliceSprite } from './NineSliceSprite';\n\nexport class NineSliceSpritePipe implements RenderPipe<NineSliceSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'nineSliceSprite',\n    } as const;\n\n    private readonly _renderer: Renderer;\n    private readonly _gpuSpriteHash: Record<number, BatchableMesh> = Object.create(null);\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_gpuSpriteHash');\n    }\n\n    public addRenderable(sprite: NineSliceSprite, instructionSet: InstructionSet)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n    }\n\n    public updateRenderable(sprite: NineSliceSprite)\n    {\n        const gpuSprite = this._gpuSpriteHash[sprite.uid];\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        gpuSprite._batcher.updateElement(gpuSprite);\n    }\n\n    public validateRenderable(sprite: NineSliceSprite): boolean\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        return !gpuSprite._batcher.checkAndUpdateTexture(\n            gpuSprite,\n            sprite._texture\n        );\n    }\n\n    public destroyRenderable(sprite: NineSliceSprite)\n    {\n        const batchableMesh = this._gpuSpriteHash[sprite.uid];\n\n        // this will call reset!\n        BigPool.return(batchableMesh.geometry as PoolItem);\n        BigPool.return(batchableMesh as PoolItem);\n\n        this._gpuSpriteHash[sprite.uid] = null;\n\n        sprite.off('destroyed', this._destroyRenderableBound);\n    }\n\n    private _updateBatchableSprite(sprite: NineSliceSprite, batchableSprite: BatchableMesh)\n    {\n        (batchableSprite.geometry as NineSliceGeometry)\n            .update(sprite);\n\n        // = sprite.bounds;\n        batchableSprite.setTexture(sprite._texture);\n    }\n\n    private _getGpuSprite(sprite: NineSliceSprite): BatchableMesh\n    {\n        return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);\n    }\n\n    private _initGPUSprite(sprite: NineSliceSprite): BatchableMesh\n    {\n        const batchableMesh = BigPool.get(BatchableMesh);\n\n        batchableMesh.geometry = BigPool.get(NineSliceGeometry);\n        batchableMesh.renderable = sprite;\n        batchableMesh.transform = sprite.groupTransform;\n        batchableMesh.texture = sprite._texture;\n        batchableMesh.roundPixels = (this._renderer._roundPixels | sprite._roundPixels) as 0 | 1;\n\n        this._gpuSpriteHash[sprite.uid] = batchableMesh;\n\n        // if the sprite has not been updated by the view, we need to update the batchable mesh now.\n        if (!sprite.didViewUpdate)\n        {\n            this._updateBatchableSprite(sprite, batchableMesh);\n        }\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        sprite.on('destroyed', this._destroyRenderableBound);\n\n        return batchableMesh;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuSpriteHash)\n        {\n            const batchableMesh = this._gpuSpriteHash[i];\n\n            batchableMesh.geometry.destroy();\n        }\n\n        (this._gpuSpriteHash as null) = null;\n        (this._renderer as null) = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { NineSliceSpritePipe } from './NineSliceSpritePipe';\n\nextensions.add(NineSliceSpritePipe);\n","import { ExtensionType } from '../extensions/Extensions';\n\nimport type { InstructionSet } from '../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { Container } from '../scene/container/Container';\nimport type { Effect } from '../scene/container/Effect';\nimport type { FilterInstruction } from './FilterSystem';\n\nexport class FilterPipe implements InstructionPipe<FilterInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'filter',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(filterEffect: Effect, container: Container, instructionSet: InstructionSet): void\n    {\n        const renderPipes = this._renderer.renderPipes;\n\n        renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            canBundle: false,\n            action: 'pushFilter',\n            container,\n            filterEffect,\n        } as FilterInstruction);\n    }\n\n    public pop(_filterEffect: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: FilterInstruction)\n    {\n        if (instruction.action === 'pushFilter')\n        {\n            this._renderer.filter.push(instruction);\n        }\n        else if (instruction.action === 'popFilter')\n        {\n            this._renderer.filter.pop();\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { Matrix } from '../maths/matrix/Matrix';\nimport { Point } from '../maths/point/Point';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../rendering/renderers/types';\nimport { Bounds } from '../scene/container/bounds/Bounds';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds';\nimport { warn } from '../utils/logging/warn';\n\nimport type { WebGLRenderer } from '../rendering/renderers/gl/WebGLRenderer';\nimport type { WebGPURenderer } from '../rendering/renderers/gpu/WebGPURenderer';\nimport type { Instruction } from '../rendering/renderers/shared/instructions/Instruction';\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { RenderTarget } from '../rendering/renderers/shared/renderTarget/RenderTarget';\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Container } from '../scene/container/Container';\nimport type { Sprite } from '../scene/sprite/Sprite';\nimport type { Filter } from './Filter';\nimport type { FilterEffect } from './FilterEffect';\n\ntype FilterAction = 'pushFilter' | 'popFilter';\n\n//\nconst quadGeometry = new Geometry({\n    attributes: {\n        aPosition: {\n            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            format: 'float32x2',\n            stride: 2 * 4,\n            offset: 0,\n        },\n    },\n    indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\n/**\n * The filter pipeline is responsible for applying filters scene items!\n *\n * KNOWN BUGS:\n * 1. Global bounds calculation is incorrect if it is used when flip flopping filters. The maths can be found below\n * eg: filters [noiseFilter, blurFilter] noiseFilter will calculate the global bounds incorrectly.\n *\n * 2. RenderGroups do not work with filters. This is because the renderGroup matrix is not currently taken into account.\n *\n * Implementation notes:\n * 1. Gotcha - nesting filters that require blending will not work correctly. This creates a chicken and egg problem\n * the complexity and performance required to do this is not worth it i feel.. but lets see if others agree!\n *\n * 2. Filters are designed to be changed on the fly, this is means that changing filter information each frame will\n * not trigger an instruction rebuild. If you are constantly turning a filter on and off.. its therefore better to set\n * enabled to true or false on the filter. Or setting an empty array.\n *\n * 3. Need to look at perhaps aliasing when flip flopping filters. Really we should only need to antialias the FIRST\n * Texture we render too. The rest can be non aliased. This might help performance.\n * Currently we flip flop with an antialiased texture if antialiasing is enabled on the filter.\n */\nexport interface FilterInstruction extends Instruction\n{\n    renderPipeId: 'filter',\n    action: FilterAction,\n    container?: Container,\n    renderables?: Renderable[],\n    filterEffect: FilterEffect,\n}\n\nexport interface FilterData\n{\n    skip: boolean;\n    enabledLength?: number;\n    inputTexture: Texture\n    bounds: Bounds,\n    blendRequired: boolean,\n    container: Container,\n    filterEffect: FilterEffect,\n    previousRenderSurface: RenderSurface,\n    backTexture?: Texture,\n}\n\n/**\n * System that manages the filter pipeline\n * @memberof rendering\n */\nexport class FilterSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'filter',\n    } as const;\n\n    public readonly renderer: Renderer;\n\n    private _filterStackIndex = 0;\n    private _filterStack: FilterData[] = [];\n\n    private readonly _filterGlobalUniforms = new UniformGroup({\n        uInputSize: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputPixel: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputClamp: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uGlobalFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputTexture: { value: new Float32Array(4), type: 'vec4<f32>' },\n    });\n\n    private readonly _globalFilterBindGroup: BindGroup = new BindGroup({});\n    private _activeFilterData: FilterData;\n\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n     * @readonly\n     */\n    public get activeBackTexture(): Texture | undefined\n    {\n        return this._activeFilterData?.backTexture;\n    }\n\n    public push(instruction: FilterInstruction)\n    {\n        const renderer = this.renderer;\n\n        const filters = instruction.filterEffect.filters;\n\n        if (!this._filterStack[this._filterStackIndex])\n        {\n            this._filterStack[this._filterStackIndex] = this._getFilterData();\n        }\n\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        this._filterStackIndex++;\n\n        // if there are no filters, we skip the pass\n        if (filters.length === 0)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        const bounds: Bounds = filterData.bounds;\n\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n        if (instruction.renderables)\n        {\n            getGlobalRenderableBounds(instruction.renderables, bounds);\n        }\n        // if a filterArea is provided, we save our selves some measuring and just use that area supplied\n        else if (instruction.filterEffect.filterArea)\n        {\n            bounds.clear();\n\n            // transform the filterArea into global space..\n            bounds.addRect(instruction.filterEffect.filterArea);\n\n            // new for v8, we transform the bounds into the space of the container\n            bounds.applyMatrix(instruction.container.worldTransform);\n        }\n        // classic filter path, we get the bounds of the container and use it by recursively\n        // measuring.\n        else\n        {\n            // we want to factor render layers to get the real visual bounds of this container.\n            // so the last param is true..\n            instruction.container.getFastGlobalBounds(true, bounds);\n        }\n\n        if (instruction.container)\n        {\n            // When a container is cached as a texture, its filters need to be applied relative to its\n            // cached parent's coordinate space rather than world space. This transform adjustment ensures\n            // filters are applied in the correct coordinate system.\n            const renderGroup = instruction.container.renderGroup || instruction.container.parentRenderGroup;\n            const filterFrameTransform = renderGroup.cacheToLocalTransform;\n\n            if (filterFrameTransform)\n            {\n                bounds.applyMatrix(filterFrameTransform);\n            }\n        }\n\n        // get GLOBAL bounds of the item we are going to apply the filter to\n\n        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n\n        // next we get the settings for the filter\n        // we need to find the LOWEST resolution for the filter list\n        let resolution = Infinity;\n        // Padding is additive to add padding to our padding\n        let padding = 0;\n        // if this is true for all filter, it should be true, and otherwise false\n        let antialias = true;\n        // true if any filter requires the previous render target\n        let blendRequired = false;\n        // true if any filter in the list is enabled\n        let enabled = false;\n        // false if any filter in the list has false\n        let clipToViewport = true;\n\n        for (let i = 0; i < filters.length; i++)\n        {\n            const filter = filters[i];\n\n            resolution = Math.min(resolution, filter.resolution === 'inherit'\n                ? colorTextureSource._resolution : filter.resolution);\n            padding += filter.padding;\n\n            if (filter.antialias === 'off')\n            {\n                antialias = false;\n            }\n            else if (filter.antialias === 'inherit')\n            {\n                antialias &&= colorTextureSource.antialias;\n            }\n\n            if (!filter.clipToViewport)\n            {\n                clipToViewport = false;\n            }\n\n            const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n\n            if (!isCompatible)\n            {\n                enabled = false;\n                break;\n            }\n\n            if (filter.blendRequired && !((renderer as WebGLRenderer).backBuffer?.useBackBuffer ?? true))\n            {\n                // #if _DEBUG\n                // eslint-disable-next-line max-len\n                warn('Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.');\n                // #endif\n\n                enabled = false;\n                break;\n            }\n\n            enabled = filter.enabled || enabled;\n            blendRequired ||= filter.blendRequired;\n        }\n\n        // if no filters are enabled lets skip!\n        if (!enabled)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // here we constrain the bounds to the viewport we will render too\n        // this should not take into account the x, y offset of the viewport - as this is\n        // handled by the viewport on the gpu.\n        if (clipToViewport)\n        {\n            const viewPort = renderer.renderTarget.rootViewPort;\n\n            const rootResolution = renderer.renderTarget.renderTarget.resolution;\n\n            bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);\n        }\n\n        // round the bounds to the nearest pixel\n        bounds\n            .scale(resolution)\n            .ceil()\n            .scale(1 / resolution)\n            .pad(padding | 0);\n\n        // skip if the bounds are negative or zero as this means they are\n        // not visible on the screen\n        if (!bounds.isPositive)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // set all the filter data\n        filterData.skip = false;\n\n        filterData.bounds = bounds;\n        filterData.blendRequired = blendRequired;\n        filterData.container = instruction.container;\n        filterData.filterEffect = instruction.filterEffect;\n\n        filterData.previousRenderSurface = renderer.renderTarget.renderSurface;\n\n        // bind...\n        // get a P02 texture from our pool...\n        filterData.inputTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            resolution,\n            antialias,\n        );\n\n        renderer.renderTarget.bind(filterData.inputTexture, true);\n        // set the global uniforms to take into account the bounds offset required\n\n        renderer.globalUniforms.push({\n            offset: bounds,\n        });\n    }\n\n    public pop()\n    {\n        const renderer = this.renderer;\n\n        this._filterStackIndex--;\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        // if we are skipping this filter then we just do nothing :D\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        this._activeFilterData = filterData;\n\n        const inputTexture = filterData.inputTexture;\n\n        const bounds = filterData.bounds;\n\n        let backTexture = Texture.EMPTY;\n\n        renderer.renderTarget.finishRenderPass();\n\n        if (filterData.blendRequired)\n        {\n            // this actually forces the current commandQueue to render everything so far.\n            // if we don't do this, we won't be able to copy pixels for the background\n            const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;\n\n            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);\n\n            backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);\n        }\n\n        filterData.backTexture = backTexture;\n\n        const filters = filterData.filterEffect.filters;\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n\n        // update the resources on the bind group...\n        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n        this._globalFilterBindGroup.setResource(backTexture.source, 3);\n\n        renderer.globalUniforms.pop();\n\n        if (filters.length === 1)\n        {\n            // render a single filter...\n            // this.applyFilter(filters[0], inputTexture, filterData.previousRenderSurface, false);\n            filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);\n\n            // return the texture to the pool so we can reuse the next frame\n            TexturePool.returnTexture(inputTexture);\n        }\n        else\n        {\n            let flip = filterData.inputTexture;\n\n            // get another texture that we will render the next filter too\n            let flop = TexturePool.getOptimalTexture(\n                bounds.width,\n                bounds.height,\n                flip.source._resolution,\n                false\n            );\n\n            let i = 0;\n\n            // loop and apply the filters, omitting the last one as we will render that to the final target\n            for (i = 0; i < filters.length - 1; ++i)\n            {\n                const filter = filters[i];\n\n                filter.apply(this, flip, flop, true);\n                const t = flip;\n\n                flip = flop;\n                flop = t;\n            }\n\n            filters[i].apply(this, flip, filterData.previousRenderSurface, false);\n\n            // return those textures for later!\n            TexturePool.returnTexture(flip);\n            TexturePool.returnTexture(flop);\n        }\n\n        // if we made a background texture, lets return that also\n        if (filterData.blendRequired)\n        {\n            TexturePool.returnTexture(backTexture);\n        }\n    }\n\n    public getBackTexture(lastRenderSurface: RenderTarget, bounds: Bounds, previousBounds?: Bounds)\n    {\n        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n\n        const backTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            backgroundResolution,\n            false,\n        );\n\n        let x = bounds.minX;\n        let y = bounds.minY;\n\n        if (previousBounds)\n        {\n            x -= previousBounds.minX;\n            y -= previousBounds.minY;\n        }\n\n        x = Math.floor(x * backgroundResolution);\n        y = Math.floor(y * backgroundResolution);\n\n        const width = Math.ceil(bounds.width * backgroundResolution);\n        const height = Math.ceil(bounds.height * backgroundResolution);\n\n        this.renderer.renderTarget.copyToTexture(\n            lastRenderSurface,\n            backTexture,\n            { x, y },\n            { width, height },\n            { x: 0, y: 0 }\n        );\n\n        return backTexture;\n    }\n\n    public applyFilter(filter: Filter, input: Texture, output: RenderSurface, clear: boolean)\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        const bounds = filterData.bounds;\n\n        const offset = Point.shared;\n        const previousRenderSurface = filterData.previousRenderSurface;\n\n        const isFinalTarget = previousRenderSurface === output;\n\n        let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n\n        // to find the previous resolution we need to account for the skipped filters\n        // the following will find the last non skipped filter...\n        let currentIndex = this._filterStackIndex - 1;\n\n        while (currentIndex > 0 && this._filterStack[currentIndex].skip)\n        {\n            --currentIndex;\n        }\n\n        if (currentIndex > 0)\n        {\n            resolution = this._filterStack[currentIndex].inputTexture.source._resolution;\n        }\n\n        const filterUniforms = this._filterGlobalUniforms;\n        const uniforms = filterUniforms.uniforms;\n\n        const outputFrame = uniforms.uOutputFrame;\n        const inputSize = uniforms.uInputSize;\n        const inputPixel = uniforms.uInputPixel;\n        const inputClamp = uniforms.uInputClamp;\n        const globalFrame = uniforms.uGlobalFrame;\n        const outputTexture = uniforms.uOutputTexture;\n\n        // are we rendering back to the original surface?\n        if (isFinalTarget)\n        {\n            let lastIndex = this._filterStackIndex;\n\n            // get previous bounds.. we must take into account skipped filters also..\n            while (lastIndex > 0)\n            {\n                lastIndex--;\n                const filterData = this._filterStack[this._filterStackIndex - 1];\n\n                if (!filterData.skip)\n                {\n                    offset.x = filterData.bounds.minX;\n                    offset.y = filterData.bounds.minY;\n\n                    break;\n                }\n            }\n\n            outputFrame[0] = bounds.minX - offset.x;\n            outputFrame[1] = bounds.minY - offset.y;\n        }\n        else\n        {\n            outputFrame[0] = 0;\n            outputFrame[1] = 0;\n        }\n\n        outputFrame[2] = input.frame.width;\n        outputFrame[3] = input.frame.height;\n\n        inputSize[0] = input.source.width;\n        inputSize[1] = input.source.height;\n        inputSize[2] = 1 / inputSize[0];\n        inputSize[3] = 1 / inputSize[1];\n\n        inputPixel[0] = input.source.pixelWidth;\n        inputPixel[1] = input.source.pixelHeight;\n        inputPixel[2] = 1.0 / inputPixel[0];\n        inputPixel[3] = 1.0 / inputPixel[1];\n\n        inputClamp[0] = 0.5 * inputPixel[2];\n        inputClamp[1] = 0.5 * inputPixel[3];\n        inputClamp[2] = (input.frame.width * inputSize[2]) - (0.5 * inputPixel[2]);\n        inputClamp[3] = (input.frame.height * inputSize[3]) - (0.5 * inputPixel[3]);\n\n        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n\n        globalFrame[0] = offset.x * resolution;\n        globalFrame[1] = offset.y * resolution;\n\n        globalFrame[2] = rootTexture.source.width * resolution;\n        globalFrame[3] = rootTexture.source.height * resolution;\n\n        // set the output texture - this is where we are going to render to\n\n        const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n\n        renderer.renderTarget.bind(output, !!clear);\n\n        if (output instanceof Texture)\n        {\n            outputTexture[0] = output.frame.width;\n            outputTexture[1] = output.frame.height;\n        }\n        else\n        {\n            // this means a renderTarget was passed directly\n            outputTexture[0] = renderTarget.width;\n            outputTexture[1] = renderTarget.height;\n        }\n\n        outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n        filterUniforms.update();\n\n        // TODO - should prolly use a adaptor...\n        if ((renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            const batchUniforms = (renderer as WebGPURenderer).renderPipes.uniformBatch\n                .getUboResource(filterUniforms);\n\n            this._globalFilterBindGroup.setResource(batchUniforms, 0);\n        }\n        else\n        {\n            this._globalFilterBindGroup.setResource(filterUniforms, 0);\n        }\n\n        // now lets update the output texture...\n\n        // set bind group..\n        this._globalFilterBindGroup.setResource(input.source, 1);\n        this._globalFilterBindGroup.setResource(input.source.style, 2);\n\n        filter.groups[0] = this._globalFilterBindGroup;\n\n        renderer.encoder.draw({\n            geometry: quadGeometry,\n            shader: filter,\n            state: filter._state,\n            topology: 'triangle-list'\n        });\n\n        // WebGPU blit's automatically, but WebGL does not!\n        if (renderer.type === RendererType.WEBGL)\n        {\n            renderer.renderTarget.finishRenderPass();\n        }\n    }\n\n    private _getFilterData(): FilterData\n    {\n        return {\n            skip: false,\n            inputTexture: null,\n            bounds: new Bounds(),\n            container: null,\n            filterEffect: null,\n            blendRequired: false,\n            previousRenderSurface: null,\n        };\n    }\n\n    /**\n     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n     *\n     * Use `outputMatrix * vTextureCoord` in the shader.\n     * @param outputMatrix - The matrix to output to.\n     * @param {Sprite} sprite - The sprite to map to.\n     * @returns The mapped matrix.\n     */\n    public calculateSpriteMatrix(outputMatrix: Matrix, sprite: Sprite): Matrix\n    {\n        const data = this._activeFilterData;\n\n        const mappedMatrix = outputMatrix.set(\n            data.inputTexture._source.width,\n            0, 0,\n            data.inputTexture._source.height,\n            data.bounds.minX, data.bounds.minY\n        );\n\n        const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n\n        const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;\n\n        if (renderGroup && renderGroup.cacheToLocalTransform)\n        {\n            // get the matrix relative to the render group..\n            worldTransform.prepend(renderGroup.cacheToLocalTransform);\n        }\n\n        worldTransform.invert();\n        mappedMatrix.prepend(worldTransform);\n        mappedMatrix.scale(\n            1.0 / sprite.texture.frame.width,\n            1.0 / sprite.texture.frame.height\n        );\n\n        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n        return mappedMatrix;\n    }\n\n    public destroy?: () => void;\n}\n","import type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Bounds } from './Bounds';\n\nexport function getGlobalRenderableBounds(renderables: Renderable[], bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    // instead of copying the matrix each time we are assigning it in bounds\n    // this is a performance hack :D\n    // so we need to restore the matrix after we are done\n\n    const tempMatrix = bounds.matrix;\n\n    for (let i = 0; i < renderables.length; i++)\n    {\n        const renderable = renderables[i];\n\n        if (renderable.globalDisplayStatus < 0b111)\n        {\n            continue;\n        }\n\n        bounds.matrix = renderable.worldTransform;\n        bounds.addBounds(renderable.bounds);\n    }\n\n    bounds.matrix = tempMatrix;\n\n    return bounds;\n}\n","import { extensions } from '../extensions/Extensions';\nimport { FilterPipe } from './FilterPipe';\nimport { FilterSystem } from './FilterSystem';\n\nextensions.add(FilterSystem);\nextensions.add(FilterPipe);\n","import type { WebGLRenderer } from '../../../rendering/renderers/gl/WebGLRenderer';\nimport type { ParticleContainer } from '../shared/ParticleContainer';\nimport type { ParticleContainerAdaptor, ParticleContainerPipe } from '../shared/ParticleContainerPipe';\n\nexport class GlParticleContainerAdaptor implements ParticleContainerAdaptor\n{\n    public execute(particleContainerPipe: ParticleContainerPipe, container: ParticleContainer)\n    {\n        const state = particleContainerPipe.state;\n        const renderer = particleContainerPipe.renderer as WebGLRenderer;\n        const shader = container.shader || particleContainerPipe.defaultShader;\n\n        shader.resources.uTexture = container.texture._source;\n        shader.resources.uniforms = particleContainerPipe.localUniforms;\n\n        const gl = renderer.gl;\n\n        const buffer = particleContainerPipe.getBuffers(container);\n\n        // now lets upload and render the buffers..\n        renderer.shader.bind(shader);\n        renderer.state.set(state);\n        renderer.geometry.bind(buffer.geometry, shader.glProgram);\n\n        const byteSize = buffer.geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n        const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n\n        gl.drawElements(gl.TRIANGLES, container.particleChildren.length * 6, glType, 0);\n    }\n}\n","/**\n * Generic Mask Stack data structure\n * @function createIndicesForQuads\n * @param {number} size - Number of quads\n * @param {Uint16Array|Uint32Array} [outBuffer] - Buffer for output, length has to be `6 * size`\n * @returns {Uint16Array|Uint32Array} - Resulting index buffer\n */\nexport function createIndicesForQuads(\n    size: number,\n    outBuffer: Uint16Array | Uint32Array | null = null\n): Uint16Array | Uint32Array\n{\n    // the total number of indices in our array, there are 6 points per quad.\n    const totalIndices = size * 6;\n\n    // Check if we need to use Uint32Array\n    if (totalIndices > 65535)\n    {\n        outBuffer ||= new Uint32Array(totalIndices); // Use Uint32Array if needed\n    }\n    else\n    {\n        outBuffer ||= new Uint16Array(totalIndices);\n    }\n\n    if (outBuffer.length !== totalIndices)\n    {\n        throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);\n    }\n\n    // fill the indices with the quads to draw\n    for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4)\n    {\n        outBuffer[i + 0] = j + 0;\n        outBuffer[i + 1] = j + 1;\n        outBuffer[i + 2] = j + 2;\n        outBuffer[i + 3] = j + 0;\n        outBuffer[i + 4] = j + 2;\n        outBuffer[i + 5] = j + 3;\n    }\n\n    return outBuffer;\n}\n","import {\n    getAttributeInfoFromFormat\n} from '../../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { IParticle } from '../Particle';\nimport type { ParticleRendererProperty } from '../particleData';\n\n// TODO rename to update function\nexport type ParticleUpdateFunction = (ps: IParticle[], f32v: Float32Array, u32v: Uint32Array) => void;\n\nexport function generateParticleUpdateFunction(properties: Record<string, ParticleRendererProperty>)\n{\n    return {\n        dynamicUpdate: generateUpdateFunction(properties, true),\n        staticUpdate: generateUpdateFunction(properties, false),\n    };\n}\n\nfunction generateUpdateFunction(\n    properties: Record<string, ParticleRendererProperty>,\n    dynamic: boolean\n): ParticleUpdateFunction\n{\n    const funcFragments: string[] = [];\n\n    funcFragments.push(`\n      \n        var index = 0;\n\n        for (let i = 0; i < ps.length; ++i)\n        {\n            const p = ps[i];\n\n            `);\n\n    let offset = 0;\n\n    for (const i in properties)\n    {\n        const property = properties[i];\n\n        if (dynamic !== property.dynamic) continue;\n\n        funcFragments.push(`offset = index + ${offset}`);\n\n        funcFragments.push(property.code);\n\n        const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n        offset += attributeInfo.stride / 4;\n    }\n\n    funcFragments.push(`\n            index += stride * 4;\n        }\n    `);\n\n    // add to the front..\n    funcFragments.unshift(`\n        var stride = ${offset};\n    `);\n\n    const functionSource = funcFragments.join('\\n');\n\n    // eslint-disable-next-line no-new-func\n    return new Function('ps', 'f32v', 'u32v', functionSource) as ParticleUpdateFunction;\n}\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { getAttributeInfoFromFormat } from '../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer';\nimport { createIndicesForQuads } from './utils/createIndicesForQuads';\nimport { generateParticleUpdateFunction } from './utils/generateParticleUpdateFunction';\n\nimport type { IndexBufferArray } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport type { IParticle } from './Particle';\nimport type { ParticleRendererProperty } from './particleData';\nimport type { ParticleUpdateFunction } from './utils/generateParticleUpdateFunction';\n\n/**\n * Options for creating a ParticleBuffer.\n * @property {number} size - The size of the particle buffer.\n * @property {Record<string, ParticleRendererProperty>} properties - A record of attributes that the particle container uses.\n */\nexport interface ParticleBufferOptions\n{\n    size: number;\n    properties: Record<string, ParticleRendererProperty>;\n}\n\n/**\n * The ParticleBuffer holds the buffers and geometry for a particle container.\n * It also contains the upload functions for the static and dynamic properties.\n * @internal\n */\nexport class ParticleBuffer\n{\n    /** The buffer containing static attribute data for all elements in the batch. */\n    public staticAttributeBuffer: ViewableBuffer;\n    /** The buffer containing dynamic attribute data for all elements in the batch. */\n    public dynamicAttributeBuffer: ViewableBuffer;\n\n    private readonly _staticBuffer: Buffer;\n    private readonly _dynamicBuffer: Buffer;\n\n    /** The buffer containing index data for all elements in the batch. */\n    public indexBuffer: IndexBufferArray;\n\n    private readonly _dynamicStride: number;\n    private readonly _staticStride: number;\n\n    /** The geometry of the particle buffer. */\n    public readonly geometry: Geometry;\n\n    private _size = 0;\n    private readonly _dynamicUpload: ParticleUpdateFunction;\n    private readonly _staticUpload: ParticleUpdateFunction;\n    private readonly _generateParticleUpdateCache: Record<string, {\n        dynamicUpdate: ParticleUpdateFunction;\n        staticUpdate: ParticleUpdateFunction;\n    }> = {};\n\n    constructor(options: ParticleBufferOptions)\n    {\n        // size in sprites!\n        const size = this._size = options.size ?? 1000;\n\n        // TODO add the option to specify what is dynamic!\n        const properties = options.properties;\n\n        // in bytes!\n        let staticVertexSize = 0;\n        let dynamicVertexSize = 0;\n\n        for (const i in properties)\n        {\n            const property = properties[i];\n            const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n            if (property.dynamic)\n            {\n                // dynamic.\n                dynamicVertexSize += attributeInfo.stride;\n            }\n            else\n            {\n                // static.\n                staticVertexSize += attributeInfo.stride;\n            }\n        }\n\n        this._dynamicStride = dynamicVertexSize / 4;\n        this._staticStride = staticVertexSize / 4;\n\n        this.staticAttributeBuffer = new ViewableBuffer(size * 4 * staticVertexSize);\n        this.dynamicAttributeBuffer = new ViewableBuffer(size * 4 * dynamicVertexSize);\n\n        this.indexBuffer = createIndicesForQuads(size);\n\n        // build geometry..\n\n        const geometry = new Geometry();\n\n        let dynamicOffset = 0;\n        let staticOffset = 0;\n\n        this._staticBuffer = new Buffer({\n            data: new Float32Array(1),\n            label: 'static-particle-buffer',\n            shrinkToFit: false,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n        });\n\n        this._dynamicBuffer = new Buffer({\n            data: new Float32Array(1),\n            label: 'dynamic-particle-buffer',\n            shrinkToFit: false,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n        });\n\n        for (const i in properties)\n        {\n            const property = properties[i];\n            const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n            if (property.dynamic)\n            {\n                geometry.addAttribute(property.attributeName, {\n                    buffer: this._dynamicBuffer,\n                    stride: this._dynamicStride * 4,\n                    offset: dynamicOffset * 4,\n                    format: property.format,\n                });\n                dynamicOffset += attributeInfo.size;\n            }\n            else\n            {\n                geometry.addAttribute(property.attributeName, {\n                    buffer: this._staticBuffer,\n                    stride: this._staticStride * 4,\n                    offset: staticOffset * 4,\n                    format: property.format,\n                });\n                staticOffset += attributeInfo.size;\n            }\n        }\n\n        geometry.addIndex(this.indexBuffer);\n\n        const uploadFunction = this.getParticleUpdate(properties);\n\n        this._dynamicUpload = uploadFunction.dynamicUpdate;\n        this._staticUpload = uploadFunction.staticUpdate;\n\n        this.geometry = geometry;\n    }\n\n    public getParticleUpdate(properties: Record<string, ParticleRendererProperty>)\n    {\n        const key = getParticleSyncKey(properties);\n\n        if (this._generateParticleUpdateCache[key])\n        {\n            return this._generateParticleUpdateCache[key];\n        }\n\n        this._generateParticleUpdateCache[key] = this.generateParticleUpdate(properties);\n\n        return this._generateParticleUpdateCache[key];\n    }\n\n    public generateParticleUpdate(properties: Record<string, ParticleRendererProperty>)\n    {\n        return generateParticleUpdateFunction(properties);\n    }\n\n    public update(particles: IParticle[], uploadStatic: boolean)\n    {\n        // first resize the buffers if needed!\n        // TODO resize!\n        if (particles.length > this._size)\n        {\n            uploadStatic = true;\n\n            this._size = Math.max(particles.length, (this._size * 1.5) | 0);\n\n            this.staticAttributeBuffer = new ViewableBuffer(this._size * this._staticStride * 4 * 4);\n            this.dynamicAttributeBuffer = new ViewableBuffer(this._size * this._dynamicStride * 4 * 4);\n            this.indexBuffer = createIndicesForQuads(this._size);\n\n            this.geometry.indexBuffer.setDataWithSize(\n                this.indexBuffer, this.indexBuffer.byteLength, true);\n        }\n\n        const dynamicAttributeBuffer = this.dynamicAttributeBuffer;\n\n        this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);\n\n        this._dynamicBuffer.setDataWithSize(\n            this.dynamicAttributeBuffer.float32View, particles.length * this._dynamicStride * 4, true);\n\n        if (uploadStatic)\n        {\n            const staticAttributeBuffer = this.staticAttributeBuffer;\n\n            this._staticUpload(particles, staticAttributeBuffer.float32View, staticAttributeBuffer.uint32View);\n\n            this._staticBuffer.setDataWithSize(\n                staticAttributeBuffer.float32View, particles.length * this._staticStride * 4, true);\n        }\n    }\n\n    public destroy()\n    {\n        this._staticBuffer.destroy();\n        this._dynamicBuffer.destroy();\n        this.geometry.destroy();\n    }\n}\n\nfunction getParticleSyncKey(properties: Record<string, ParticleRendererProperty>)\n{\n    const keyGen: string[] = [];\n\n    for (const key in properties)\n    {\n        const property = properties[key];\n\n        keyGen.push(key, property.code, property.dynamic ? 'd' : 's');\n    }\n\n    return keyGen.join('_');\n}\n\n","import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { GlProgram } from '../../../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../../../rendering/renderers/gpu/shader/GpuProgram';\nimport { Shader } from '../../../../rendering/renderers/shared/shader/Shader';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { TextureStyle } from '../../../../rendering/renderers/shared/texture/TextureStyle';\nimport fragment from './particles.frag';\nimport vertex from './particles.vert';\nimport wgsl from './particles.wgsl';\n\nexport class ParticleShader extends Shader\n{\n    constructor()\n    {\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment\n        });\n\n        const gpuProgram = GpuProgram.from({\n            fragment: {\n                source: wgsl,\n                entryPoint: 'mainFragment'\n            },\n            vertex: {\n                source: wgsl,\n                entryPoint: 'mainVertex'\n            }\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                // this will be replaced with the texture from the particle container\n                uTexture: Texture.WHITE.source,\n                // this will be replaced with the texture style from the particle container\n                uSampler: new TextureStyle({}),\n                // this will be replaced with the local uniforms from the particle container\n                uniforms: {\n                    uTranslationMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n                    uColor: { value: new Color(0xFFFFFF), type: 'vec4<f32>' },\n                    uRound: { value: 1, type: 'f32' },\n                    uResolution: { value: [0, 0], type: 'vec2<f32>' },\n                }\n            }\n        });\n    }\n}\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { ParticleBuffer } from './ParticleBuffer';\nimport { ParticleShader } from './shader/ParticleShader';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Container } from '../../container/Container';\nimport type { ParticleContainer } from './ParticleContainer';\n\nexport interface ParticleContainerAdaptor\n{\n    execute(particleContainerPop: ParticleContainerPipe, container: ParticleContainer): void;\n}\n\n/**\n * Renderer for Particles that is designer for speed over feature set.\n * @memberof scene\n */\nexport class ParticleContainerPipe implements RenderPipe<ParticleContainer>\n{\n    /** The default shader that is used if a sprite doesn't have a more specific one. */\n    public defaultShader: Shader;\n\n    public adaptor: ParticleContainerAdaptor;\n    public readonly state = State.for2d();\n    public readonly renderer: Renderer;\n\n    private _gpuBufferHash: Record<number, ParticleBuffer> = Object.create(null);\n    // eslint-disable-next-line max-len\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as unknown as (renderable: Container) => void;\n\n    public readonly localUniforms = new UniformGroup({\n        uTranslationMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uRound: { value: 1, type: 'f32' },\n        uResolution: { value: [0, 0], type: 'vec2<f32>' },\n    });\n\n    /**\n     * @param renderer - The renderer this sprite batch works for.\n     * @param adaptor\n     */\n    constructor(renderer: Renderer, adaptor: ParticleContainerAdaptor)\n    {\n        this.renderer = renderer;\n\n        this.adaptor = adaptor;\n\n        this.defaultShader = new ParticleShader();\n\n        this.state = State.for2d();\n    }\n\n    public validateRenderable(_renderable: ParticleContainer): boolean\n    {\n        // always fine :D\n        return false;\n    }\n\n    public addRenderable(renderable: ParticleContainer, instructionSet: InstructionSet)\n    {\n        this.renderer.renderPipes.batch.break(instructionSet);\n        instructionSet.add(renderable);\n    }\n\n    public getBuffers(renderable: ParticleContainer): ParticleBuffer\n    {\n        return this._gpuBufferHash[renderable.uid] || this._initBuffer(renderable);\n    }\n\n    private _initBuffer(renderable: ParticleContainer): ParticleBuffer\n    {\n        this._gpuBufferHash[renderable.uid] = new ParticleBuffer({\n            size: renderable.particleChildren.length,\n            properties: renderable._properties,\n        });\n\n        renderable.on('destroyed', this._destroyRenderableBound);\n\n        return this._gpuBufferHash[renderable.uid];\n    }\n\n    public updateRenderable(_renderable: ParticleContainer)\n    {\n        // nothing to be done here!\n\n    }\n\n    public destroyRenderable(renderable: ParticleContainer)\n    {\n        const buffer = this._gpuBufferHash[renderable.uid];\n\n        buffer.destroy();\n\n        this._gpuBufferHash[renderable.uid] = null;\n\n        renderable.off('destroyed', this._destroyRenderableBound);\n    }\n\n    public execute(container: ParticleContainer): void\n    {\n        const children = container.particleChildren;\n\n        if (children.length === 0)\n        {\n            return;\n        }\n\n        const renderer = this.renderer;\n        const buffer = this.getBuffers(container);\n\n        container.texture ||= children[0].texture;\n\n        const state = this.state;\n\n        buffer.update(children, container._childrenDirty);\n        container._childrenDirty = false;\n\n        state.blendMode = getAdjustedBlendModeBlend(container.blendMode, container.texture._source);\n\n        const uniforms = this.localUniforms.uniforms;\n\n        const transformationMatrix = uniforms.uTranslationMatrix;\n\n        container.worldTransform.copyTo(transformationMatrix);\n\n        transformationMatrix.prepend(renderer.globalUniforms.globalUniformData.projectionMatrix);\n\n        uniforms.uResolution = renderer.globalUniforms.globalUniformData.resolution;\n        uniforms.uRound = renderer._roundPixels | container._roundPixels;\n\n        color32BitToUniform(\n            container.groupColorAlpha,\n            uniforms.uColor,\n            0\n        );\n\n        this.adaptor.execute(this, container);\n    }\n\n    /** Destroys the ParticleRenderer. */\n    public destroy(): void\n    {\n        if (this.defaultShader)\n        {\n            this.defaultShader.destroy();\n            this.defaultShader = null;\n        }\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { GlParticleContainerAdaptor } from '../gl/GlParticleContainerAdaptor';\nimport { ParticleContainerPipe } from './ParticleContainerPipe';\n\nimport type { WebGLRenderer } from '../../../rendering/renderers/gl/WebGLRenderer';\n\nexport class GlParticleContainerPipe extends ParticleContainerPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n        ],\n        name: 'particle',\n    } as const;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        super(renderer, new GlParticleContainerAdaptor());\n    }\n}\n","import type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\nimport type { ParticleContainer } from '../shared/ParticleContainer';\nimport type { ParticleContainerAdaptor, ParticleContainerPipe } from '../shared/ParticleContainerPipe';\n\nexport class GpuParticleContainerAdaptor implements ParticleContainerAdaptor\n{\n    public execute(particleContainerPipe: ParticleContainerPipe, container: ParticleContainer)\n    {\n        const renderer = particleContainerPipe.renderer as WebGPURenderer;\n\n        const shader = container.shader || particleContainerPipe.defaultShader;\n\n        shader.groups[0] = renderer.renderPipes.uniformBatch.getUniformBindGroup(particleContainerPipe.localUniforms, true);\n\n        shader.groups[1] = renderer.texture.getTextureBindGroup(container.texture);\n\n        const state = particleContainerPipe.state;\n\n        const buffer = particleContainerPipe.getBuffers(container);\n\n        renderer.encoder.draw({\n            geometry: buffer.geometry,\n            shader: container.shader || particleContainerPipe.defaultShader,\n            state,\n            size: container.particleChildren.length * 6,\n        });\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { GpuParticleContainerAdaptor } from '../gpu/GpuParticleContainerAdaptor';\nimport { ParticleContainerPipe } from './ParticleContainerPipe';\n\nimport type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\n\nexport class GpuParticleContainerPipe extends ParticleContainerPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipes,\n        ],\n        name: 'particle',\n    } as const;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        super(renderer, new GpuParticleContainerAdaptor());\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { GlParticleContainerPipe } from './shared/GlParticleContainerPipe';\nimport { GpuParticleContainerPipe } from './shared/GpuParticleContainerPipe';\n\n// NOTE: this is the first occurrence of needing both gl and gpu pipes in the same file\n// This could cause some issues with tree shaking in the future.\n// Right now these two files do not import anything specific for a renderer, so is not an issue for now.\nextensions.add(GlParticleContainerPipe);\nextensions.add(GpuParticleContainerPipe);\n","import { updateQuadBounds } from '../../../utils/data/updateQuadBounds';\nimport { type BatchableSprite } from '../../sprite/BatchableSprite';\nimport { type AbstractText } from '../AbstractText';\n\n/**\n * Updates the bounds of the given batchable sprite based on the provided text object.\n *\n * This function adjusts the bounds of the batchable sprite to match the dimensions\n * and anchor point of the text's texture. Additionally, it compensates for any padding\n * specified in the text's style to ensure the text is rendered correctly on screen.\n * @param {BatchableSprite} batchableSprite - The sprite whose bounds need to be updated.\n * @param {AbstractText} text - The text object containing the texture and style information.\n */\nexport function updateTextBounds(batchableSprite: BatchableSprite, text: AbstractText)\n{\n    const { texture, bounds } = batchableSprite;\n\n    updateQuadBounds(bounds, text._anchor, texture);\n\n    const padding = text._style.padding;\n    // When HTML text textures are created, they include the padding around the text content\n    // to prevent text clipping and provide a buffer zone. This padding is built into\n    // the texture itself. However, we don't want this padding to affect the text's\n    // actual position on screen.\n    // To compensate, we shift the render position back by the padding amount,\n    // ensuring the text appears exactly where intended while maintaining the\n    // buffer zone around it.\n\n    bounds.minX -= padding;\n    bounds.minY -= padding;\n    bounds.maxX -= padding;\n    bounds.maxY -= padding;\n}\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../sprite/BatchableSprite';\nimport { updateTextBounds } from '../text/utils/updateTextBounds';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { Container } from '../container/Container';\nimport type { HTMLText } from './HTMLText';\nimport type { HTMLTextStyle } from './HTMLTextStyle';\n\nexport class HTMLTextPipe implements RenderPipe<HTMLText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _gpuText: Record<number, {\n        textureNeedsUploading: boolean;\n        generatingTexture: boolean;\n        texture: Texture,\n        currentKey: string,\n        batchableSprite: BatchableSprite,\n    }> = Object.create(null);\n\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.runners.resolutionChange.add(this);\n        this._renderer.renderableGC.addManagedHash(this, '_gpuText');\n    }\n\n    public resolutionChange()\n    {\n        for (const i in this._gpuText)\n        {\n            const gpuText = this._gpuText[i];\n\n            if (!gpuText) continue;\n\n            const text = gpuText.batchableSprite.renderable as HTMLText;\n\n            if (text._autoResolution)\n            {\n                text._resolution = this._renderer.resolution;\n                text.onViewUpdate();\n            }\n        }\n    }\n\n    public validateRenderable(htmlText: HTMLText): boolean\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const newKey = htmlText._getKey();\n\n        if (gpuText.textureNeedsUploading)\n        {\n            gpuText.textureNeedsUploading = false;\n\n            return true;\n        }\n\n        if (gpuText.currentKey !== newKey)\n        {\n            // TODO - could look into optimising this a tad!\n            // if its a single texture, then we could just swap it?\n            // same for CanvasText..\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(htmlText: HTMLText, instructionSet: InstructionSet)\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (htmlText._didTextUpdate)\n        {\n            this._updateText(htmlText);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableSprite, instructionSet);\n    }\n\n    public updateRenderable(htmlText: HTMLText)\n    {\n        const gpuText = this._getGpuText(htmlText);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (htmlText._didTextUpdate)\n        {\n            this._updateText(htmlText);\n        }\n\n        batchableSprite._batcher.updateElement(batchableSprite);\n    }\n\n    public destroyRenderable(htmlText: HTMLText)\n    {\n        htmlText.off('destroyed', this._destroyRenderableBound);\n        this._destroyRenderableById(htmlText.uid);\n    }\n\n    private _destroyRenderableById(htmlTextUid: number)\n    {\n        const gpuText = this._gpuText[htmlTextUid];\n\n        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n\n        BigPool.return(gpuText.batchableSprite);\n\n        this._gpuText[htmlTextUid] = null;\n    }\n\n    private _updateText(htmlText: HTMLText)\n    {\n        const newKey = htmlText._getKey();\n        const gpuText = this._getGpuText(htmlText);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            this._updateGpuText(htmlText).catch((e) =>\n            {\n                console.error(e);\n            });\n        }\n\n        htmlText._didTextUpdate = false;\n\n        updateTextBounds(batchableSprite, htmlText);\n    }\n\n    private async _updateGpuText(htmlText: HTMLText)\n    {\n        htmlText._didTextUpdate = false;\n\n        const gpuText = this._getGpuText(htmlText);\n\n        if (gpuText.generatingTexture) return;\n\n        const newKey = htmlText._getKey();\n\n        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n\n        gpuText.generatingTexture = true;\n\n        gpuText.currentKey = newKey;\n\n        const resolution = htmlText.resolution ?? this._renderer.resolution;\n\n        const texture = await this._renderer.htmlText.getManagedTexture(\n            htmlText.text,\n            resolution,\n            htmlText._style as HTMLTextStyle,\n            htmlText._getKey()\n        );\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        batchableSprite.texture = gpuText.texture = texture;\n\n        gpuText.generatingTexture = false;\n\n        gpuText.textureNeedsUploading = true;\n        htmlText.onViewUpdate();\n\n        updateTextBounds(batchableSprite, htmlText);\n    }\n\n    private _getGpuText(htmlText: HTMLText)\n    {\n        return this._gpuText[htmlText.uid] || this.initGpuText(htmlText);\n    }\n\n    public initGpuText(htmlText: HTMLText)\n    {\n        const gpuTextData: HTMLTextPipe['_gpuText'][number] = {\n            texture: Texture.EMPTY,\n            currentKey: '--',\n            batchableSprite: BigPool.get(BatchableSprite),\n            textureNeedsUploading: false,\n            generatingTexture: false,\n        };\n\n        const batchableSprite = gpuTextData.batchableSprite;\n\n        batchableSprite.renderable = htmlText;\n        batchableSprite.transform = htmlText.groupTransform;\n        batchableSprite.texture = Texture.EMPTY;\n        batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        batchableSprite.roundPixels = (this._renderer._roundPixels | htmlText._roundPixels) as 0 | 1;\n\n        htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n        this._gpuText[htmlText.uid] = gpuTextData;\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        htmlText.on('destroyed', this._destroyRenderableBound);\n\n        return gpuTextData;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuText)\n        {\n            this._destroyRenderableById(i as unknown as number);\n        }\n\n        this._gpuText = null;\n        this._renderer = null;\n    }\n}\n\n","import type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\n\nexport const nssvg = 'http://www.w3.org/2000/svg';\nexport const nsxhtml = 'http://www.w3.org/1999/xhtml';\n\nexport class HTMLTextRenderData\n{\n    public svgRoot = document.createElementNS(nssvg, 'svg');\n    public foreignObject = document.createElementNS(nssvg, 'foreignObject');\n    public domElement = document.createElementNS(nsxhtml, 'div');\n    public styleElement = document.createElementNS(nsxhtml, 'style');\n    public image = new Image();\n    public canvasAndContext?: CanvasAndContext;\n\n    constructor()\n    {\n        const { foreignObject, svgRoot, styleElement, domElement } = this;\n        // Arbitrary max size\n\n        foreignObject.setAttribute('width', '10000');\n        foreignObject.setAttribute('height', '10000');\n        foreignObject.style.overflow = 'hidden';\n\n        svgRoot.appendChild(foreignObject);\n\n        foreignObject.appendChild(styleElement);\n        foreignObject.appendChild(domElement);\n    }\n}\n","import { Color } from '../../../color/Color';\n\nimport type { ConvertedStrokeStyle } from '../../graphics/shared/FillTypes';\nimport type { TextStyle } from '../../text/TextStyle';\nimport type { HTMLTextStyle, HTMLTextStyleOptions } from '../HTMLTextStyle';\n\n/**\n * Internally converts all of the style properties into CSS equivalents.\n * @param style\n * @returns The CSS style string, for setting `style` property of root HTMLElement.\n */\nexport function textStyleToCSS(style: HTMLTextStyle): string\n{\n    const stroke = style._stroke;\n    const fill = style._fill;\n\n    const cssStyleString = [\n        `color: ${Color.shared.setValue(fill.color).toHex()}`,\n        `font-size: ${(style.fontSize as number)}px`,\n        `font-family: ${style.fontFamily}`,\n        `font-weight: ${style.fontWeight}`,\n        `font-style: ${style.fontStyle}`,\n        `font-variant: ${style.fontVariant}`,\n        `letter-spacing: ${style.letterSpacing}px`,\n        `text-align: ${style.align}`,\n        `padding: ${style.padding}px`,\n        `white-space: ${(style.whiteSpace === 'pre' && style.wordWrap) ? 'pre-wrap' : style.whiteSpace}`,\n        ...style.lineHeight ? [`line-height: ${style.lineHeight}px`] : [],\n        ...style.wordWrap ? [\n            `word-wrap: ${style.breakWords ? 'break-all' : 'break-word'}`,\n            `max-width: ${style.wordWrapWidth}px`\n        ] : [],\n        ...stroke ? [strokeToCSS(stroke)] : [],\n        ...style.dropShadow ? [dropShadowToCSS(style.dropShadow)] : [],\n        ...style.cssOverrides,\n    ].join(';');\n\n    const cssStyles = [`div { ${cssStyleString} }`];\n\n    tagStyleToCSS(style.tagStyles, cssStyles);\n\n    return cssStyles.join(' ');\n}\n\nfunction dropShadowToCSS(dropShadowStyle: TextStyle['dropShadow']): string\n{\n    const color = Color.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();\n    const x = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);\n    const y = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);\n\n    const position = `${x}px ${y}px`;\n\n    if (dropShadowStyle.blur > 0)\n    {\n        return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;\n    }\n\n    return `text-shadow: ${position} ${color}`;\n}\n\nfunction strokeToCSS(stroke: ConvertedStrokeStyle): string\n{\n    return [\n        `-webkit-text-stroke-width: ${stroke.width}px`,\n        `-webkit-text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,\n        `text-stroke-width: ${stroke.width}px`,\n        `text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,\n        'paint-order: stroke',\n    ].join(';');\n}\n\n/** Converts the tag styles into CSS. */\nconst templates = {\n    fontSize: `font-size: {{VALUE}}px`,\n    fontFamily: `font-family: {{VALUE}}`,\n    fontWeight: `font-weight: {{VALUE}}`,\n    fontStyle: `font-style: {{VALUE}}`,\n    fontVariant: `font-variant: {{VALUE}}`,\n    letterSpacing: `letter-spacing: {{VALUE}}px`,\n    align: `text-align: {{VALUE}}`,\n    padding: `padding: {{VALUE}}px`,\n    whiteSpace: `white-space: {{VALUE}}`,\n    lineHeight: `line-height: {{VALUE}}px`,\n    wordWrapWidth: `max-width: {{VALUE}}px`,\n};\n\n/** Converts the tag styles into CSS if modifications are required */\nconst transform = {\n    fill: (value: string) => `color: ${Color.shared.setValue(value).toHex()}`,\n    breakWords: (value: string) => `word-wrap: ${value ? 'break-all' : 'break-word'}`,\n    stroke: strokeToCSS,\n    dropShadow: dropShadowToCSS\n};\n\nfunction tagStyleToCSS(tagStyles: Record<string, HTMLTextStyleOptions>, out: string[])\n{\n    for (const i in tagStyles)\n    {\n        const tagStyle = tagStyles[i];\n        const cssTagStyle = [];\n\n        for (const j in tagStyle)\n        {\n            if (transform[j as keyof typeof transform])\n            {\n                cssTagStyle.push(transform[j as keyof typeof transform](tagStyle[j as keyof HTMLTextStyleOptions] as any));\n            }\n            else if (templates[j as keyof typeof templates])\n            {\n                // eslint-disable-next-line max-len\n                cssTagStyle.push(templates[j as keyof typeof templates].replace('{{VALUE}}', tagStyle[j as keyof HTMLTextStyleOptions] as any));\n            }\n        }\n\n        out.push(`${i} { ${cssTagStyle.join(';')} }`);\n    }\n}\n","/* eslint-disable accessor-pairs */\nimport { warn } from '../../utils/logging/warn';\nimport { TextStyle } from '../text/TextStyle';\nimport { generateTextStyleKey } from '../text/utils/generateTextStyleKey';\nimport { textStyleToCSS } from './utils/textStyleToCSS';\n\nimport type { FillInput, StrokeInput } from '../graphics/shared/FillTypes';\nimport type { TextStyleOptions } from '../text/TextStyle';\n\n/**\n * Options for HTML text style, extends {@link TextStyle}.\n * @memberof text\n * @extends text.TextStyleOptions\n * @property {string[]} [cssOverrides] - CSS style(s) to add.\n * @property {Record<string, text.HTMLTextStyleOptions>} [tagStyles] - Tag styles.\n */\nexport interface HTMLTextStyleOptions extends Omit<TextStyleOptions, 'leading' | 'textBaseline' | 'trim' >\n{\n    cssOverrides?: string[];\n    tagStyles?: Record<string, HTMLTextStyleOptions>;\n}\n\n/**\n * A TextStyle object rendered by the HTMLTextSystem.\n * @memberof text\n */\nexport class HTMLTextStyle extends TextStyle\n{\n    private _cssOverrides: string[] = [];\n    private _cssStyle: string;\n    /**\n     * List of styles per tag.\n     * @example\n     * new HTMLText({\n     *   text:'<red>Red</red>,<blue>Blue</blue>,<green>Green</green>',\n     *   style:{\n     *       fontFamily: 'DM Sans',\n     *       fill: 'white',\n     *       fontSize:100,\n     *       tagStyles:{\n     *           red:{\n     *               fill:'red',\n     *           },\n     *           blue:{\n     *               fill:'blue',\n     *           },\n     *           green:{\n     *               fill:'green',\n     *           }\n     *       }\n     *   }\n     * );\n     */\n    public tagStyles: Record<string, HTMLTextStyleOptions>;\n\n    constructor(options: HTMLTextStyleOptions = {})\n    {\n        super(options);\n\n        this.cssOverrides ??= options.cssOverrides;\n        this.tagStyles = options.tagStyles ?? {};\n    }\n\n    /** List of style overrides that will be applied to the HTML text. */\n    set cssOverrides(value: string | string[])\n    {\n        this._cssOverrides = value instanceof Array ? value : [value];\n        this.update();\n    }\n\n    get cssOverrides(): string[]\n    {\n        return this._cssOverrides;\n    }\n\n    protected override _generateKey(): string\n    {\n        this._styleKey = generateTextStyleKey(this) + this._cssOverrides.join('-');\n\n        return this._styleKey;\n    }\n\n    public update()\n    {\n        this._cssStyle = null;\n        super.update();\n    }\n\n    /**\n     * Creates a new HTMLTextStyle object with the same values as this one.\n     * @returns New cloned HTMLTextStyle object\n     */\n    public clone(): HTMLTextStyle\n    {\n        return new HTMLTextStyle({\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this.dropShadow ? { ...this.dropShadow } : null,\n            fill: this._fill,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth,\n            cssOverrides: this.cssOverrides,\n        });\n    }\n\n    get cssStyle(): string\n    {\n        if (!this._cssStyle)\n        {\n            this._cssStyle = textStyleToCSS(this);\n        }\n\n        return this._cssStyle;\n    }\n\n    /**\n     * Add a style override, this can be any CSS property\n     * it will override any built-in style. This is the\n     * property and the value as a string (e.g., `color: red`).\n     * This will override any other internal style.\n     * @param {string} value - CSS style(s) to add.\n     * @example\n     * style.addOverride('background-color: red');\n     */\n    public addOverride(...value: string[]): void\n    {\n        const toAdd = value.filter((v) => !this.cssOverrides.includes(v));\n\n        if (toAdd.length > 0)\n        {\n            this.cssOverrides.push(...toAdd);\n            this.update();\n        }\n    }\n\n    /**\n     * Remove any overrides that match the value.\n     * @param {string} value - CSS style to remove.\n     * @example\n     * style.removeOverride('background-color: red');\n     */\n    public removeOverride(...value: string[]): void\n    {\n        const toRemove = value.filter((v) => this.cssOverrides.includes(v));\n\n        if (toRemove.length > 0)\n        {\n            this.cssOverrides = this.cssOverrides.filter((v) => !toRemove.includes(v));\n            this.update();\n        }\n    }\n\n    override set fill(value: FillInput)\n    {\n        // if its not a string or a number, then its a texture!\n        if (typeof value !== 'string' && typeof value !== 'number')\n        {\n            // #if _DEBUG\n            warn('[HTMLTextStyle] only color fill is not supported by HTMLText');\n            // #endif\n        }\n\n        super.fill = value;\n    }\n\n    override set stroke(value: StrokeInput)\n    {\n        // if its not a string or a number, then its a texture!\n        if (value && typeof value !== 'string' && typeof value !== 'number')\n        {\n            // #if _DEBUG\n            warn('[HTMLTextStyle] only color stroke is not supported by HTMLText');\n            // #endif\n        }\n\n        super.stroke = value;\n    }\n}\n","import { loadFontAsBase64 } from './loadFontAsBase64';\n\nexport interface FontCSSStyleOptions\n{\n    fontFamily: string | string[]\n    fontWeight: string\n    fontStyle: string\n}\n\n/**\n * This will take a font url and a style and return a css string that can be injected into a style tag\n * This will contain inlined base64 font and the font family information\n * @param style - the style to generate the css for\n * @param url - The url to load the font from\n * @returns - The css string\n */\nexport async function loadFontCSS(style: FontCSSStyleOptions, url: string): Promise<string>\n{\n    const dataSrc = await loadFontAsBase64(url);\n\n    return `@font-face {\n        font-family: \"${style.fontFamily}\";\n        src: url('${dataSrc}');\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n    }`;\n}\n","import { DOMAdapter } from '../../../environment/adapter';\n\n/**\n * Resolves a font url to a base64 string\n * @param url - The url to load the font from\n * @returns - The font as a base64 string\n */\nexport async function loadFontAsBase64(url: string): Promise<string>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    const blob = await response.blob();\n\n    const reader = new FileReader();\n\n    const dataSrc: string = await new Promise((resolve, reject) =>\n    {\n        reader.onloadend = () => resolve(reader.result as string);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n    });\n\n    return dataSrc;\n}\n","import { Cache } from '../../../assets/cache/Cache';\nimport { loadFontCSS } from './loadFontCSS';\n\nimport type { FontCSSStyleOptions } from './loadFontCSS';\n\nexport const FontStylePromiseCache = new Map<string, Promise<string>>();\n\n/**\n * takes the font families and returns a css string that can be injected into a style tag\n * It will contain the font families and the font urls encoded as base64\n * @param fontFamilies - The font families to load\n * @param style - The FontCSSStyleOptions to load the font with (used for the first font family)\n * @param defaultOptions - The default options to load the font with (used for the rest of the font families)\n * @param defaultOptions.fontWeight - The default font weight\n * @param defaultOptions.fontStyle - The default font style\n * @returns - The css string\n */\nexport async function getFontCss(\n    fontFamilies: string[],\n    style: FontCSSStyleOptions,\n    defaultOptions: {fontWeight: string, fontStyle: string}\n)\n{\n    const fontPromises = fontFamilies\n        .filter((fontFamily) => Cache.has(`${fontFamily}-and-url`))\n        .map((fontFamily, i) =>\n        {\n            if (!FontStylePromiseCache.has(fontFamily))\n            {\n                const { url } = Cache.get(`${fontFamily}-and-url`);\n\n                if (i === 0)\n                {\n                    FontStylePromiseCache.set(fontFamily, loadFontCSS({\n                        fontWeight: style.fontWeight,\n                        fontStyle: style.fontStyle,\n                        fontFamily,\n                    }, url));\n                }\n\n                else\n                {\n                    FontStylePromiseCache.set(fontFamily, loadFontCSS({\n                        fontWeight: defaultOptions.fontWeight,\n                        fontStyle: defaultOptions.fontStyle,\n                        fontFamily,\n                    }, url));\n                }\n            }\n\n            return FontStylePromiseCache.get(fontFamily);\n        });\n\n    return (await Promise.all(fontPromises)).join('\\n');\n}\n","import { HTMLTextRenderData } from '../HTMLTextRenderData';\n\nimport type { Size } from '../../../maths/misc/Size';\nimport type { HTMLTextStyle } from '../HTMLTextStyle';\n\nlet tempHTMLTextRenderData: HTMLTextRenderData;\n\n/**\n * Measures the HTML text without actually generating an image.\n * This is used to calculate the size of the text.\n * @param text - The text to measure\n * @param style - The style to use\n * @param fontStyleCSS - The font css to use\n * @param htmlTextRenderData - The HTMLTextRenderData to write the SVG to\n * @returns - The size of the text\n */\nexport function measureHtmlText(\n    text: string,\n    style: HTMLTextStyle,\n    fontStyleCSS?: string,\n    htmlTextRenderData?: HTMLTextRenderData\n): Size\n{\n    htmlTextRenderData ||= tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());\n\n    const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n\n    domElement.innerHTML = `<style>${style.cssStyle};</style><div style='padding:0'>${text}</div>`;\n\n    domElement.setAttribute('style', 'transform-origin: top left; display: inline-block');\n\n    if (fontStyleCSS)\n    {\n        styleElement.textContent = fontStyleCSS;\n    }\n\n    // Measure the contents using the shadow DOM\n    document.body.appendChild(svgRoot);\n\n    const contentBounds = domElement.getBoundingClientRect();\n\n    svgRoot.remove();\n\n    // padding is included in the CSS calculation, so we need to remove it here\n    const doublePadding = style.padding * 2;\n\n    return {\n        width: contentBounds.width - doublePadding,\n        height: contentBounds.height - doublePadding,\n    };\n}\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { type CanvasAndContext, CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { isSafari } from '../../utils/browser/isSafari';\nimport { warn } from '../../utils/logging/warn';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { getPo2TextureFromSource } from '../text/utils/getPo2TextureFromSource';\nimport { HTMLTextRenderData } from './HTMLTextRenderData';\nimport { HTMLTextStyle } from './HTMLTextStyle';\nimport { extractFontFamilies } from './utils/extractFontFamilies';\nimport { getFontCss } from './utils/getFontCss';\nimport { getSVGUrl } from './utils/getSVGUrl';\nimport { getTemporaryCanvasFromImage } from './utils/getTemporaryCanvasFromImage';\nimport { loadSVGImage } from './utils/loadSVGImage';\nimport { measureHtmlText } from './utils/measureHtmlText';\n\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { HTMLTextOptions } from './HTMLText';\nimport type { FontCSSStyleOptions } from './utils/loadFontCSS';\n\ninterface HTMLTextTexture\n{\n    texture: Texture,\n    usageCount: number,\n    promise: Promise<Texture>,\n}\n\n/**\n * System plugin to the renderer to manage HTMLText\n * @memberof rendering\n */\nexport class HTMLTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    public static defaultFontOptions: FontCSSStyleOptions = {\n        fontFamily: 'Arial',\n        fontStyle: 'normal',\n        fontWeight: 'normal',\n    };\n\n    private _activeTextures: Record<string, HTMLTextTexture> = {};\n\n    /**\n     * WebGPU has a cors issue when uploading an image that is an SVGImage\n     * To get around this we need to create a canvas draw the image to it and upload that instead.\n     * Bit of a shame.. but no other work around just yet!\n     */\n    private readonly _createCanvas: boolean;\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._createCanvas = renderer.type === RendererType.WEBGPU;\n    }\n\n    public getTexture(options: HTMLTextOptions): Promise<Texture>\n    {\n        return this._buildTexturePromise(\n            options.text as string,\n            options.resolution,\n            options.style as HTMLTextStyle\n        );\n    }\n\n    public getManagedTexture(\n        text: string,\n        resolution: number,\n        style: HTMLTextStyle,\n        textKey: string\n    ): Promise<Texture>\n    {\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].promise;\n        }\n\n        const promise = this._buildTexturePromise(text, resolution, style)\n            .then((texture) =>\n            {\n                this._activeTextures[textKey].texture = texture;\n\n                return texture;\n            });\n\n        this._activeTextures[textKey] = {\n            texture: null,\n            promise,\n            usageCount: 1,\n        };\n\n        return promise;\n    }\n\n    private async _buildTexturePromise(\n        text: string,\n        resolution: number,\n        style: HTMLTextStyle,\n    )\n    {\n        const htmlTextData = BigPool.get(HTMLTextRenderData);\n        const fontFamilies = extractFontFamilies(text, style);\n        const fontCSS = await getFontCss(\n            fontFamilies,\n            style,\n            HTMLTextStyle.defaultTextStyle as {fontWeight: string, fontStyle: string}\n        );\n        const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const image = htmlTextData.image;\n\n        // this off set will ensure we don't get any UV bleeding!\n        const uvSafeOffset = 2;\n\n        image.width = (width | 0) + uvSafeOffset;\n        image.height = (height | 0) + uvSafeOffset;\n\n        const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n\n        await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n\n        const resource: HTMLImageElement | HTMLCanvasElement = image;\n        let canvasAndContext: CanvasAndContext;\n\n        if (this._createCanvas)\n        {\n            // silly webGPU workaround..\n            canvasAndContext = getTemporaryCanvasFromImage(image, resolution);\n        }\n\n        const texture = getPo2TextureFromSource(canvasAndContext ? canvasAndContext.canvas : resource,\n            image.width - uvSafeOffset,\n            image.height - uvSafeOffset,\n            resolution\n        );\n\n        if (this._createCanvas)\n        {\n            this._renderer.texture.initSource(texture.source);\n            CanvasPool.returnCanvasAndContext(canvasAndContext);\n        }\n\n        BigPool.return(htmlTextData as PoolItem);\n\n        return texture;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        // TODO SHOULD NOT BE NEEDED\n        if (!activeTexture) return;\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            if (activeTexture.texture)\n            {\n                this._cleanUp(activeTexture);\n            }\n            else\n            {\n                // we did not resolve...\n                activeTexture.promise.then((texture) =>\n                {\n                    activeTexture.texture = texture;\n\n                    this._cleanUp(activeTexture);\n                }).catch(() =>\n                {\n                    // #if _DEBUG\n                    warn('HTMLTextSystem: Failed to clean texture');\n                    // #endif\n                });\n            }\n\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    private _cleanUp(activeTexture: HTMLTextTexture)\n    {\n        TexturePool.returnTexture(activeTexture.texture);\n        activeTexture.texture.source.resource = null;\n        activeTexture.texture.source.uploadMethodId = 'unknown';\n    }\n\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey].usageCount;\n    }\n\n    public destroy(): void\n    {\n        this._activeTextures = null;\n    }\n}\n","import type { HTMLTextStyle } from '../HTMLTextStyle';\n\n/**\n * Extracts font families from text. It will extract font families from the style, tagStyles and any font families\n * embedded in the text. It should also strip out duplicates as it goes.\n * @param  text - The text to extract font families from\n * @param style - The style to extract font families from\n * @returns {string[]} - The font families as an array of strings\n */\nexport function extractFontFamilies(text: string, style: HTMLTextStyle): string[]\n{\n    const fontFamily = style.fontFamily;\n    const fontFamilies: string[] = [];\n    const dedupe: Record<string, boolean> = {};\n\n    // first ensure fonts are loaded inline..\n    // find any font..\n    const regex = /font-family:([^;\"\\s]+)/g;\n\n    const matches = text.match(regex);\n\n    function addFontFamily(fontFamily: string)\n    {\n        if (!dedupe[fontFamily])\n        {\n            fontFamilies.push(fontFamily);\n\n            dedupe[fontFamily] = true;\n        }\n    }\n\n    if (Array.isArray(fontFamily))\n    {\n        for (let i = 0; i < fontFamily.length; i++)\n        {\n            addFontFamily(fontFamily[i]);\n        }\n    }\n    else\n    {\n        addFontFamily(fontFamily);\n    }\n\n    if (matches)\n    {\n        matches.forEach((match) =>\n        {\n            const fontFamily = match.split(':')[1].trim();\n\n            addFontFamily(fontFamily);\n        });\n    }\n\n    for (const i in style.tagStyles)\n    {\n        const fontFamily = style.tagStyles[i].fontFamily;\n\n        addFontFamily(fontFamily as string);\n    }\n\n    return fontFamilies;\n}\n","import type { HTMLTextRenderData } from '../HTMLTextRenderData';\nimport type { HTMLTextStyle } from '../HTMLTextStyle';\n\n/**\n * takes all the data and returns a svg url string can be loaded by an image element\n * @param text - The text to measure\n * @param style - The style to use\n * @param resolution - The resolution to use\n * @param fontCSS - The font css to use\n * @param htmlTextData - The HTMLTextRenderData to write the SVG to\n * @returns - The SVG as a url string\n */\nexport function getSVGUrl(\n    text: string,\n    style: HTMLTextStyle,\n    resolution: number,\n    fontCSS: string,\n    htmlTextData: HTMLTextRenderData\n)\n{\n    const { domElement, styleElement, svgRoot } = htmlTextData;\n\n    domElement.innerHTML = `<style>${style.cssStyle}</style><div style='padding:0;'>${text}</div>`;\n    domElement.setAttribute('style', `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n    styleElement.textContent = fontCSS;\n\n    const { width, height } = htmlTextData.image;\n\n    svgRoot.setAttribute('width', width.toString());\n    svgRoot.setAttribute('height', height.toString());\n\n    return new XMLSerializer().serializeToString(svgRoot);\n}\n","/**\n * This function loads an SVG image into an HTMLImageElement.\n * The image can then be uploaded as texture to the GPU.\n * iOS has a bug where embedded fonts are not available immediately after the image loads,\n * so we wait an arbitrary amount of time before resolving the promise.\n * @param image - The image to load the SVG into\n * @param url - The url to load the SVG from\n * @param delay - Whether to delay the load\n * @returns - A promise that resolves when the image has loaded\n */\nexport function loadSVGImage(image: HTMLImageElement, url: string, delay: boolean)\n{\n    return new Promise<void>(async (resolve) =>\n    {\n        // Safari has a known bug where embedded fonts are not available\n        // immediately after the image loads, to compensate we wait an\n        // arbitrary amount of time\n        // @see https://bugs.webkit.org/show_bug.cgi?id=219770\n        if (delay)\n        {\n            await new Promise<void>((resolve) => setTimeout(resolve, 100));\n        }\n\n        image.onload = () =>\n        {\n            resolve();\n        };\n\n        image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n        image.crossOrigin = 'anonymous';\n    });\n}\n","import { DOMAdapter } from '../../environment/adapter';\n\nexport function isSafari(): boolean\n{\n    const { userAgent } = DOMAdapter.get().getNavigator();\n\n    return (/^((?!chrome|android).)*safari/i).test(userAgent);\n}\n","import { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\n\nimport type { CanvasAndContext } from '../../../rendering/renderers/shared/texture/CanvasPool';\n\n/**\n * This function converts an image to a canvas, and returns the canvas.\n * It is used to convert images to canvases to work around a CORS issue where WebGPU cannot\n * upload an SVGImage to a texture.\n *\n * It uses the CanvasPool to get an optimal canvas and context, and then draws the image onto it.\n * Remember to return this canvas is immediately to the CanvasPool for reuse when you are done with it.\n * (eg upload it to the GPU!)\n * @param image - The image to convert to a canvas.\n * @param resolution - The resolution of the canvas.\n */\nexport function getTemporaryCanvasFromImage(image: HTMLImageElement, resolution: number): CanvasAndContext\n{\n    // Get an optimal canvas and context from the CanvasPool, based on the\n    // dimensions of the image and the desired resolution.\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n        image.width,\n        image.height,\n        resolution\n    );\n\n    // Clear the context of the canvas, and draw the image onto it.\n    const { context } = canvasAndContext;\n\n    context.clearRect(0, 0, image.width, image.height);\n    context.drawImage(image, 0, 0);\n\n    // Return the canvas.\n    return canvasAndContext;\n}\n\n","import { extensions } from '../../extensions/Extensions';\nimport { HTMLTextPipe } from './HTMLTextPipe';\nimport { HTMLTextSystem } from './HTMLTextSystem';\n\nextensions.add(HTMLTextSystem);\nextensions.add(HTMLTextPipe);\n","export function colorToUniform(rgb: number, alpha: number, out: Float32Array, offset: number)\n{\n    // TODO replace with Color..\n    out[offset++] = ((rgb >> 16) & 0xFF) / 255;\n    out[offset++] = ((rgb >> 8) & 0xFF) / 255;\n    out[offset++] = (rgb & 0xFF) / 255;\n    out[offset++] = alpha;\n}\n\nexport function color32BitToUniform(abgr: number, out: Float32Array, offset: number)\n{\n    const alpha = ((abgr >> 24) & 0xFF) / 255;\n\n    out[offset++] = ((abgr & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 8) & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 16) & 0xFF) / 255) * alpha;\n    out[offset++] = alpha;\n}\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { BatchMode } from '../../graphics/shared/GraphicsContext';\n\n/**\n * Options for the mesh geometry.\n * @memberof scene\n */\nexport interface MeshGeometryOptions\n{\n    /** The positions of the mesh. */\n    positions?: Float32Array;\n    /** The UVs of the mesh. If not provided, they will be filled with 0 and match the size of the positions. */\n    uvs?: Float32Array;\n    /** The indices of the mesh. */\n    indices?: Uint32Array;\n    /** The topology of the mesh. */\n    topology?: Topology;\n    /** Whether to shrink the buffers to fit the data. */\n    shrinkBuffersToFit?: boolean;\n}\n\n/**\n * A geometry used to batch multiple meshes with the same texture.\n * @memberof scene\n */\nexport class MeshGeometry extends Geometry\n{\n    public static defaultOptions: MeshGeometryOptions = {\n        topology: 'triangle-list',\n        shrinkBuffersToFit: false,\n    };\n\n    public batchMode: BatchMode = 'auto';\n\n    /**\n     * @param {scene.MeshGeometryOptions} options - The options of the mesh geometry.\n     */\n    constructor(options: MeshGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(positions: Float32Array, uvs: Float32Array, indices: Uint32Array);\n    constructor(...args: [MeshGeometryOptions] | [Float32Array, Float32Array, Uint32Array])\n    {\n        let options = args[0] ?? {};\n\n        if (options instanceof Float32Array)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'use new MeshGeometry({ positions, uvs, indices }) instead');\n            // #endif\n\n            options = {\n                positions: options,\n                uvs: args[1],\n                indices: args[2],\n            };\n        }\n\n        options = { ...MeshGeometry.defaultOptions, ...options };\n\n        const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n\n        let uvs = options.uvs;\n\n        if (!uvs)\n        {\n            if (options.positions)\n            {\n                uvs = new Float32Array(positions.length);\n            }\n            else\n            {\n                uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n            }\n        }\n\n        const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n\n        const shrinkToFit = options.shrinkBuffersToFit;\n\n        const positionBuffer = new Buffer({\n            data: positions,\n            label: 'attribute-mesh-positions',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const uvBuffer = new Buffer({\n            data: uvs,\n            label: 'attribute-mesh-uvs',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const indexBuffer = new Buffer({\n            data: indices,\n            label: 'index-mesh-buffer',\n            shrinkToFit,\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST,\n        });\n\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: positionBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n                aUV: {\n                    buffer: uvBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n            },\n            indexBuffer,\n            topology: options.topology,\n        });\n    }\n\n    /** The positions of the mesh. */\n    get positions(): Float32Array\n    {\n        return this.attributes.aPosition.buffer.data as Float32Array;\n    }\n\n    /**\n     * Set the positions of the mesh.\n     * When setting the positions, its important that the uvs array is at least as long as the positions array.\n     * otherwise the geometry will not be valid.\n     * @param {Float32Array} value - The positions of the mesh.\n     */\n    set positions(value: Float32Array)\n    {\n        this.attributes.aPosition.buffer.data = value;\n    }\n\n    /** The UVs of the mesh. */\n    get uvs(): Float32Array\n    {\n        return this.attributes.aUV.buffer.data as Float32Array;\n    }\n\n    /**\n     * Set the UVs of the mesh.\n     * Its important that the uvs array you set is at least as long as the positions array.\n     * otherwise the geometry will not be valid.\n     * @param {Float32Array} value - The UVs of the mesh.\n     */\n    set uvs(value: Float32Array)\n    {\n        this.attributes.aUV.buffer.data = value;\n    }\n\n    /** The indices of the mesh. */\n    get indices(): Uint32Array\n    {\n        return this.indexBuffer.data as Uint32Array;\n    }\n\n    set indices(value: Uint32Array)\n    {\n        this.indexBuffer.data = value;\n    }\n}\n"],"names":["localUniformBit","name","vertex","header","main","end","localUniformBitGroup2","replace","localUniformBitGl","tilingBit","fragment","tilingBitGl","gpuProgram","glProgram","TilingSpriteShader","Shader","constructor","compileHighShaderGpuProgram","bits","roundPixelsBit","compileHighShaderGlProgram","roundPixelsBitGl","tilingUniforms","UniformGroup","uMapCoord","value","Matrix","type","uClampFrame","Float32Array","uClampOffset","uTextureTransform","uSizeAnchor","resources","localUniforms","uTransformMatrix","uColor","uRound","uTexture","Texture","EMPTY","source","uSampler","style","updateUniforms","width","height","matrix","anchorX","anchorY","texture","this","textureWidth","textureHeight","textureMatrix","uniforms","set","a","b","c","d","tx","ty","invert","mapCoord","QuadGeometry","MeshGeometry","positions","uvs","indices","Uint32Array","sharedQuad","TilingSpritePipe","renderer","_state","State","default2d","_tilingSpriteDataHash","Object","create","_destroyRenderableBound","destroyRenderable","bind","_renderer","renderableGC","addManagedHash","validateRenderable","renderable","tilingSpriteData","_getTilingSpriteData","couldBatch","canBatch","_updateCanBatch","batchableMesh","_batcher","checkAndUpdateTexture","addRenderable","tilingSprite","instructionSet","batcher","renderPipes","batch","geometry","BatchableMesh","didViewUpdate","_updateBatchableMesh","transform","groupTransform","setTexture","_texture","roundPixels","_roundPixels","addToBatch","break","shader","updateRenderable","add","execute","uid","groups","globalUniforms","bindGroup","color32BitToUniform","groupColorAlpha","blendMode","getAdjustedBlendModeBlend","groupBlendMode","_source","encoder","draw","state","updateElement","_tileTransform","anchor","x","y","destroy","off","_initTilingSpriteData","slice","on","renderableData","addressMode","update","frame","applyAnchorToTexture","shared","copyFrom","scale","array","stride","offset","index","size","length","applyMatrix","setUvs","setPositions","i","_nonPowOf2wrapping","RendererType","WEBGL","context","supports","nonPowOf2wrapping","isSimple","isPowerOfTwo","extension","ExtensionType","WebGLPipes","WebGPUPipes","CanvasPipes","extensions","batcherName","packAsQuad","indexOffset","attributeOffset","_batch","_textureMatrixUpdateId","_uvUpdateId","topology","_topology","reset","uvBuffer","getBuffer","data","transformedUvs","_transformedUvs","_updateID","multiplyUvs","color","attributeSize","indexSize","ResizePlugin","init","options","defineProperty","dom","globalThis","removeEventListener","queueResize","_resizeTo","addEventListener","resize","get","_cancelResize","_resizeId","requestAnimationFrame","cancelAnimationFrame","window","innerWidth","innerHeight","clientWidth","clientHeight","render","resizeTo","Application","TickerPlugin","assign","autoStart","sharedTicker","ticker","_ticker","remove","UPDATE_PRIORITY","LOW","stop","start","Ticker","oldTicker","BatchableSprite","_attributeStart","bounds","GraphicsPipe","adaptor","for2d","_graphicsBatchesHash","_adaptor","graphics","wasBatched","gpuContext","graphicsContext","updateGpuContext","isBatchable","_rebuild","_addToBatcher","batches","_removeBatchForRenderable","isRenderable","getGpuContext","customShader","_initBatchesForRenderable","batched","batchPipe","_getBatchesForRenderable","map","batchClone","BigPool","BatchableGraphics","copyTo","graphicsUid","forEach","return","GraphicsContextSystem","localUniformMSDFBit","localUniformMSDFBitGl","mSDFBit","mSDFBitGl","SdfShader","uDistance","maxTextures","getMaxTexturesPerBatch","colorBit","generateTextureBatchBit","colorBitGl","generateTextureBatchBitGl","batchSamplers","getBatchSamplersUniformGroup","BitmapTextPipe","_gpuBitmapText","bitmapText","graphicsRenderable","_getGpuBitmapText","_didTextUpdate","_updateContext","syncWithProxy","_updateDistanceField","_destroyRenderableByUid","renderableUid","proxyGraphics","bitmapFont","BitmapFontManager","getFont","text","_style","clear","distanceField","chars","Array","from","currentY","baseLineOffset","bitmapTextLayout","getBitmapTextLayout","padding","offsetY","_stroke","translate","_anchor","_x","_y","tint","applyFillAsTint","_fill","lines","line","j","charPositions","char","charData","Math","round","xOffset","yOffset","lineHeight","initGpuText","proxyRenderable","Graphics","fontFamily","dynamicFont","Cache","dx","sqrt","dy","worldScale","abs","fontScale","baseRenderedFontSize","fontSize","distance","range","container","proxy","groupColor","globalDisplayStatus","localDisplayStatus","groupAlpha","CanvasTextPipe","_gpuText","runners","resolutionChange","gpuText","batchableSprite","_autoResolution","_resolution","resolution","onViewUpdate","_getGpuText","newKey","_getKey","currentKey","_updateText","_destroyRenderableById","textUid","canvasText","decreaseReferenceCount","_updateGpuText","updateTextBounds","getManagedTexture","gpuTextData","minX","maxX","minY","maxY","checkRow","checkColumn","top","bottom","CanvasTextSystem","_activeTextures","getTextureSize","measured","CanvasTextMetrics","measureText","ceil","max","nextPow2","getTexture","_textKey","deprecation","TextStyle","canvasAndContext","createTextureAndCanvas","initSource","CanvasPool","returnCanvasAndContext","getOptimalCanvasAndContext","canvas","renderTextToCanvas","getPo2TextureFromSource","trim","trimmed","arguments","undefined","getContext","willReadFrequently","TypeError","getImageData","left","right","Rectangle","getCanvasBoundingBox","updateUvs","textKey","_increaseReferenceCount","usageCount","returnTexture","resource","uploadMethodId","alphaMode","TexturePool","activeTexture","getReferenceCount","font","fontStringFromTextStyle","lineWidths","maxLineWidth","fontProperties","resetTransform","textBaseline","strokeStyle","lineWidth","miterLimit","lineJoin","join","lineCap","cap","linePositionX","linePositionY","passesCount","dropShadow","isShadowPass","dsOffsetText","dsOffsetShadow","fillStyle","shadowOptions","dropShadowColor","dropShadowAlpha","alpha","shadowColor","Color","setValue","setAlpha","toRgbaString","dropShadowBlur","blur","dropShadowDistance","shadowBlur","shadowOffsetX","cos","angle","shadowOffsetY","sin","getCanvasFillStyle","alignment","linePositionYShift","strokeWidth","i2","ascent","align","_drawLetterSpacing","isStroke","letterSpacing","useExperimentalLetterSpacing","experimentalLetterSpacingSupported","experimentalLetterSpacing","textLetterSpacing","strokeText","fillText","currentPosition","stringArray","graphemeSegmenter","previousWidth","currentWidth","currentChar","textStr","WebGLSystem","WebGPUSystem","CanvasSystem","MeshPipe","localUniformsBindGroup","BindGroup","_meshDataHash","_gpuBatchableMeshHash","mesh","meshData","_getMeshData","isBatched","_geometry","vertexSize","_getBatchableMesh","gpuBatchableMesh","gpuMesh","_initMeshData","_initBatchableMesh","tempBounds","Bounds","image","getOptimalTexture","emit","_PlaneGeometry","super","v8_0_0","verticesX","verticesY","build","defaultOptions","total","verts","sizeX","sizeY","push","totalSub","xpos","ypos","value2","value3","value4","buffers","indexBuffer","PlaneGeometry","_NineSliceGeometry","_originalWidth","originalWidth","_originalHeight","originalHeight","_leftWidth","leftWidth","_rightWidth","rightWidth","_topHeight","topHeight","_bottomHeight","bottomHeight","_anchorX","_anchorY","updatePositions","p","w","scaleW","h","scaleH","min","anchorOffsetX","anchorOffsetY","_uvw","_uvh","NineSliceGeometry","NineSliceSpritePipe","_gpuSpriteHash","sprite","gpuSprite","_getGpuSprite","_updateBatchableSprite","_initGPUSprite","FilterPipe","filterEffect","renderPipeId","canBundle","action","pop","_filterEffect","_container","instruction","filter","quadGeometry","Geometry","attributes","aPosition","buffer","format","FilterSystem","_filterStackIndex","_filterStack","_filterGlobalUniforms","uInputSize","uInputPixel","uInputClamp","uOutputFrame","uGlobalFrame","uOutputTexture","_globalFilterBindGroup","activeBackTexture","_activeFilterData","backTexture","filters","_getFilterData","filterData","skip","renderables","tempMatrix","worldTransform","addBounds","getGlobalRenderableBounds","filterArea","addRect","getFastGlobalBounds","filterFrameTransform","renderGroup","parentRenderGroup","cacheToLocalTransform","colorTextureSource","renderTarget","colorTexture","Infinity","antialias","blendRequired","enabled","clipToViewport","compatibleRenderers","backBuffer","useBackBuffer","warn","viewPort","rootViewPort","rootResolution","fitBounds","pad","isPositive","previousRenderSurface","renderSurface","inputTexture","finishRenderPass","previousBounds","getRenderTarget","getBackTexture","setResource","apply","flip","flop","t","lastRenderSurface","backgroundResolution","floor","copyToTexture","applyFilter","input","output","Point","isFinalTarget","rootRenderTarget","currentIndex","filterUniforms","outputFrame","inputSize","inputPixel","inputClamp","globalFrame","outputTexture","lastIndex","filterData2","pixelWidth","pixelHeight","rootTexture","isRoot","uniformBatch","batchUniforms","getUboResource","calculateSpriteMatrix","outputMatrix","mappedMatrix","prepend","GlParticleContainerAdaptor","particleContainerPipe","defaultShader","gl","getBuffers","glType","BYTES_PER_ELEMENT","UNSIGNED_SHORT","UNSIGNED_INT","drawElements","TRIANGLES","particleChildren","createIndicesForQuads","outBuffer","totalIndices","Uint16Array","Error","generateUpdateFunction","properties","dynamic","funcFragments","property","code","getAttributeInfoFromFormat","unshift","functionSource","Function","ParticleBuffer","_size","_generateParticleUpdateCache","staticVertexSize","dynamicVertexSize","attributeInfo","_dynamicStride","_staticStride","staticAttributeBuffer","ViewableBuffer","dynamicAttributeBuffer","dynamicOffset","staticOffset","_staticBuffer","Buffer","label","shrinkToFit","usage","BufferUsage","VERTEX","COPY_DST","_dynamicBuffer","addAttribute","attributeName","addIndex","uploadFunction","getParticleUpdate","_dynamicUpload","dynamicUpdate","_staticUpload","staticUpdate","key","keyGen","getParticleSyncKey","generateParticleUpdate","generateParticleUpdateFunction","particles","uploadStatic","setDataWithSize","byteLength","float32View","uint32View","ParticleShader","GlProgram","GpuProgram","wgsl","entryPoint","WHITE","TextureStyle","uTranslationMatrix","uResolution","ParticleContainerPipe","_gpuBufferHash","_renderable","_initBuffer","_properties","children","_childrenDirty","transformationMatrix","globalUniformData","projectionMatrix","GlParticleContainerPipe","GpuParticleContainerAdaptor","getUniformBindGroup","getTextureBindGroup","GpuParticleContainerPipe","updateQuadBounds","HTMLTextPipe","htmlText","textureNeedsUploading","htmlTextUid","catch","e","console","error","generatingTexture","nssvg","nsxhtml","HTMLTextRenderData","svgRoot","document","createElementNS","foreignObject","domElement","styleElement","Image","setAttribute","overflow","appendChild","textStyleToCSS","stroke","fill","cssStyles","toHex","fontWeight","fontStyle","fontVariant","whiteSpace","wordWrap","breakWords","wordWrapWidth","strokeToCSS","dropShadowToCSS","cssOverrides","tagStyles","out","tagStyle","cssTagStyle","templates","tagStyleToCSS","dropShadowStyle","toHexa","position","HTMLTextStyle","_cssOverrides","_generateKey","_styleKey","generateTextStyleKey","_cssStyle","clone","cssStyle","addOverride","_len","_key","toAdd","v","includes","removeOverride","_len2","_key2","toRemove","loadFontCSS","url","dataSrc","response","DOMAdapter","fetch","blob","reader","FileReader","Promise","resolve","reject","onloadend","result","onerror","readAsDataURL","loadFontAsBase64","FontStylePromiseCache","Map","tempHTMLTextRenderData","HTMLTextSystem","_createCanvas","WEBGPU","_buildTexturePromise","promise","then","htmlTextData","fontFamilies","dedupe","matches","match","addFontFamily","fontFamily2","isArray","split","extractFontFamilies","fontCSS","fontPromises","has","all","getFontCss","defaultTextStyle","fontStyleCSS","htmlTextRenderData","innerHTML","textContent","body","contentBounds","getBoundingClientRect","doublePadding","measureHtmlText","svgURL","toString","XMLSerializer","serializeToString","getSVGUrl","delay","async","resolve2","setTimeout","onload","src","encodeURIComponent","crossOrigin","loadSVGImage","userAgent","getNavigator","test","isSafari","clearRect","drawImage","getTemporaryCanvasFromImage","_cleanUp","defaultFontOptions","abgr","_MeshGeometry","shrinkBuffersToFit","aUV","INDEX","batchMode"],"sourceRoot":""}